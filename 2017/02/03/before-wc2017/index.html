<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>WC2017前的刷题记录 | oi_loser&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
        },
        "HTML-CSS": { availableFonts: ["TeX"] }
    });
  </script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  
  <meta name="description" content="就要WC了，然而我还是一堆简单题不会做。人弱就要多刷题，于是就刷了一些我觉得很难的题。 如果大家发现有什么问题欢迎提出。  目录  1、Codeforces 717A 2、TCO2014 Round 3B Div1 1000 3、Codeforces 722E 4、Codeforces 713D 5、Codeforces 762F 6、UOJ #54 7、Codeforces 715C 8、LYD">
<meta name="keywords" content="题解,记录">
<meta property="og:type" content="article">
<meta property="og:title" content="WC2017前的刷题记录">
<meta property="og:url" content="http://yoursite.com/2017/02/03/before-wc2017/index.html">
<meta property="og:site_name" content="oi_loser&#39;s blog">
<meta property="og:description" content="就要WC了，然而我还是一堆简单题不会做。人弱就要多刷题，于是就刷了一些我觉得很难的题。 如果大家发现有什么问题欢迎提出。  目录  1、Codeforces 717A 2、TCO2014 Round 3B Div1 1000 3、Codeforces 722E 4、Codeforces 713D 5、Codeforces 762F 6、UOJ #54 7、Codeforces 715C 8、LYD">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-12-18T11:56:02.648Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="WC2017前的刷题记录">
<meta name="twitter:description" content="就要WC了，然而我还是一堆简单题不会做。人弱就要多刷题，于是就刷了一些我觉得很难的题。 如果大家发现有什么问题欢迎提出。  目录  1、Codeforces 717A 2、TCO2014 Round 3B Div1 1000 3、Codeforces 722E 4、Codeforces 713D 5、Codeforces 762F 6、UOJ #54 7、Codeforces 715C 8、LYD">
  
    <link rel="alternate" href="/atom.xml" title="oi_loser&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">oi_loser&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-before-wc2017" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/03/before-wc2017/" class="article-date">
  <time datetime="2017-02-03T12:53:53.000Z" itemprop="datePublished">2017-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      WC2017前的刷题记录
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>就要WC了，然而我还是一堆简单题不会做。人弱就要多刷题，于是就刷了一些<del>我觉得很难的</del>题。</p>
<p>如果大家发现有什么问题欢迎提出。</p>
<hr>
<h3 id="目录">目录</h3>
<ul>
<li>1、Codeforces 717A</li>
<li>2、TCO2014 Round 3B Div1 1000</li>
<li>3、Codeforces 722E</li>
<li>4、Codeforces 713D</li>
<li>5、Codeforces 762F</li>
<li>6、UOJ #54</li>
<li>7、Codeforces 715C</li>
<li>8、LYDSY 3451</li>
<li>9、UOJ #59</li>
</ul>
<hr>
<h3 id="codeforces-717a">1、Codeforces 717A</h3>
<p>给定整数 <span class="math inline">\(k,l,r\)</span>，设 <span class="math inline">\(T\)</span> 为所有<strong>长度在 <span class="math inline">\([l,r]\)</span> 间且不存在相邻两个0的01串</strong>的集合，求从 <span class="math inline">\(T\)</span> 中取出恰好 <span class="math inline">\(k\)</span> 个<strong>长度相同</strong>的串的方案数除以 <span class="math inline">\(1,000,000,007\)</span> 的余数。<span class="math inline">\(1\le k\le 200,1\le l\le r\le 10^{18}\)</span>。</p>
<p>http://codeforces.com/problemset/problem/717/A</p>
<p>这场比赛我参加过，然后挂了……主要就是一开始想了很久的这一题，一直以为是矩阵快速幂，结果想了很久没能把矩阵构造出来。最后只好放弃了这题。</p>
<p>后来看了题解才发现这题做法好神。</p>
<p>首先，记 <span class="math inline">\(f_i\)</span> 为长度等于 <span class="math inline">\(i\)</span> 且不存在相邻两个0的01串个数，显然 <span class="math inline">\(f_0=1,f_1=2\)</span>。考虑一个长度等于 <span class="math inline">\(i\)</span> 的01串，如果第 <span class="math inline">\(i\)</span> 位是1，那么只需前 <span class="math inline">\(i-1\)</span> 位不存在两个相邻的0即可，有 <span class="math inline">\(f_{i-1}\)</span> 种，如果第 <span class="math inline">\(i\)</span> 位是0，那么第 <span class="math inline">\(i-1\)</span> 位是1，有 <span class="math inline">\(f_{i-2}\)</span> 种，即</p>
<p><span class="math display">\[f_i=f_{i-1}+f_{i-2}\]</span></p>
<p>不难发现这就是一个Fibonacci数列，如果记 <span class="math inline">\(F_i=\begin{cases}i,&amp;i &lt; 2,\\F_{i-1}+F_{i-2},&amp;i\ge 2\end{cases}\)</span>，那么 <span class="math inline">\(f_i=F_{i+2}\)</span>，于是答案等于</p>
<p><span class="math display">\[\sum_{i=l}^rC_{f_i}^k=\sum_{i=l}^rC_{F_{i+2}}^k\]</span></p>
<p>用经典的计数方法，记 <span class="math inline">\(S_n=\sum_{i=0}^{n-1}C_{F_i}^k\)</span>，则答案为 <span class="math inline">\(S_{r+3}-S_{l+2}\)</span>。</p>
<p>前面的这些转化都很简单，问题来了，如何计算 <span class="math inline">\(S_i\)</span>？</p>
<a id="more"></a>
<p>组合数的式子看起来比较复杂，不过通过观察发现，<span class="math inline">\(C_x^k=\frac{1}{k!}x(x-1)(x-2)...(x-k+1)\)</span>，是一个关于 <span class="math inline">\(x\)</span> 的 <span class="math inline">\(k\)</span> 次多项式，于是设对于所有 <span class="math inline">\(x\)</span> 有 <span class="math inline">\(C_x^k=\sum_{i=0}^ka_ix^i\)</span>，显然通过 <span class="math inline">\(O(k^2)\)</span> 暴力求多项式乘法就能求出所有 <span class="math inline">\(a_i\)</span>，则现在需要计算的是</p>
<p><span class="math display">\[S_i=\sum_{i=0}^{n-1}\sum_{j=0}^ka_jF_i^j=\sum_{i=0}^ka_i\sum_{j=0}^{n-1}F_j^i\]</span></p>
<p>我在考场上就卡在了如何计算 <span class="math inline">\(\sum_{j=0}^{n-1}F_j^i\)</span> 上。用类比思想，如果 <span class="math inline">\(i=1\)</span>，那么就是求前 <span class="math inline">\(n\)</span> 项Fibonacci数的和，这个显然是矩阵快速幂可以解决的。那么 <span class="math inline">\(i\)</span> 更大的时候是不是能用一个 <span class="math inline">\(O(k)\times O(k)\)</span> 的矩阵来做呢？于是就掉坑了——<strong>就算能用矩阵做，复杂度也是错误的</strong>。</p>
<p>看了题解。正解利用到Fibonacci数的性质，更准确的说，是通项公式：</p>
<p><span class="math display">\[F_i=\frac{1}{\sqrt{5}}[(\frac{1+\sqrt{5}}{2})^i-(\frac{1-\sqrt{5}}{2})^i]\]</span></p>
<p>问题是模 <span class="math inline">\(1,000,000,007\)</span> 意义下 <span class="math inline">\(5\)</span> 没有平方根，怎么办？有一种很好的思路：用 <span class="math inline">\(\sqrt 5\)</span> 和有理数进行加、减、乘、除的结果在 <span class="math inline">\(U=\{a+b\sqrt 5|a,b\in\mathbf{Q}\}\)</span> 上封闭，因此把所有数表示为 <span class="math inline">\(a+b\sqrt 5\)</span> 即可，其中有理数的除法在模大质数 <span class="math inline">\(1,000,000,007\)</span> 意义下可以用乘法逆元来等效代替。</p>
<p>因此计算和式的时候可以展开 <span class="math inline">\(F_i\)</span>，即：</p>
<p><span class="math display">\[\sum_{j=0}^{n-1}F_j^i=(\frac{1}{\sqrt{5}})^i\sum_{j=0}^{n-1}[(\frac{1+\sqrt{5}}{2})^j-(\frac{1-\sqrt{5}}{2})^j]^i
\\ =(\frac{1}{\sqrt{5}})^i\sum_{j=0}^{n-1}\sum_{k=0}^iC_i^k(-1)^{i-k}(\frac{1+\sqrt{5}}{2})^{jk}(\frac{1-\sqrt{5}}{2})^{j(i-k)}
\\ =(\frac{1}{\sqrt{5}})^i\sum_{k=0}^iC_i^k(-1)^{i-k}\sum_{j=0}^{n-1}[(\frac{1+\sqrt{5}}{2})^k(\frac{1-\sqrt{5}}{2})^{(i-k)}]^j\]</span></p>
<p><strong>UPD：这里把和式的 <span class="math inline">\(k\)</span> 和题目给出的 <span class="math inline">\(k\)</span> 混淆了，不过由于式子中没有用到题目给出的 <span class="math inline">\(k\)</span>，所以可以忽略。</strong></p>
<p>计算 <span class="math inline">\(\sum_{j=0}^{n-1}[(\frac{1+\sqrt{5}}{2})^k(\frac{1-\sqrt{5}}{2})^{(i-k)}]^j\)</span> 可以使用快速幂在 <span class="math inline">\(O(\log n)\)</span> 时间内计算出来。这个算法枚举了 <span class="math inline">\(i,k\)</span>，所以总复杂度就是 <span class="math inline">\(O(k^2\log r)\)</span>。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> p=MOD)</span></span>&#123;<span class="keyword">return</span> a==<span class="number">1</span>?<span class="number">1</span>:(<span class="number">1</span>+p*(a-inv(p%a,a)))/a%p;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">num</span>&#123;</span> <span class="comment">// a+b*sqrt(5)</span></span><br><span class="line">	<span class="keyword">int</span> a,b;</span><br><span class="line">	num(<span class="keyword">int</span> a=<span class="number">0</span>,<span class="keyword">int</span> b=<span class="number">0</span>)&#123;<span class="keyword">this</span>-&gt;a=a;<span class="keyword">this</span>-&gt;b=b;&#125;</span><br><span class="line">	num <span class="keyword">operator</span>+(num x)&#123;<span class="keyword">return</span> num((a+x.a)%MOD,(b+x.b)%MOD);&#125;</span><br><span class="line">	num <span class="keyword">operator</span>-(num x)&#123;<span class="keyword">return</span> num((a-x.a+MOD)%MOD,(b-x.b+MOD)%MOD);&#125;</span><br><span class="line">	num <span class="keyword">operator</span>*(num x)&#123;<span class="keyword">return</span> num((<span class="number">1l</span>l*a*x.a+<span class="number">5l</span>l*b*x.b)%MOD,(<span class="number">1l</span>l*a*x.b+<span class="number">1l</span>l*b*x.a)%MOD);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">num <span class="title">pow</span><span class="params">(num a,ll n,<span class="keyword">bool</span> t=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">	num p=<span class="number">1</span>,s=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;<span class="keyword">while</span>(n&gt;&gt;i)i++;</span><br><span class="line">	<span class="keyword">while</span>(i--)&#123;</span><br><span class="line">		s=s*(p+<span class="number">1</span>),p=p*p;</span><br><span class="line">		<span class="keyword">if</span>(n&gt;&gt;i&amp;<span class="number">1</span>)s=s+p,p=p*a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t?s:p;</span><br><span class="line">&#125;</span><br><span class="line">ll a[<span class="number">210</span>],C[<span class="number">210</span>];</span><br><span class="line">num pA[<span class="number">210</span>],pB[<span class="number">210</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k;ll l,r;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;k&gt;&gt;l&gt;&gt;r;</span><br><span class="line">	*pA=*pB=*a=*C=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;(*a*=MOD+<span class="number">2</span>-++i)%=MOD)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j;j--)a[j]=(a[j<span class="number">-1</span>]+a[j]*(MOD-i+<span class="number">1</span>))%MOD;</span><br><span class="line">		pA[i]=<span class="built_in">pow</span>(num(inv(<span class="number">2</span>),inv(<span class="number">2</span>)),i);</span><br><span class="line">		pB[i]=<span class="built_in">pow</span>(num(inv(<span class="number">2</span>),MOD-inv(<span class="number">2</span>)),i);</span><br><span class="line">	&#125;</span><br><span class="line">	num S=<span class="number">0</span>,c=*a,x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++,c=<span class="built_in">pow</span>(num(<span class="number">0</span>,inv(<span class="number">5</span>)),i)*a[i])&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">			x=(<span class="built_in">pow</span>(pA[j]*pB[i-j],r+<span class="number">3</span>,<span class="number">1</span>)-<span class="built_in">pow</span>(pA[j]*pB[i-j],l+<span class="number">2</span>,<span class="number">1</span>))*(j?(C[j]+=C[j<span class="number">-1</span>])%=MOD:<span class="number">1</span>)*c;</span><br><span class="line">			i-j&amp;<span class="number">1</span>?S=S-x:S=S+x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)S=S*inv(i);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;S.a&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#top">返回顶部</a></p>
<hr>
<h3 id="tco2014-round-3b-div1-1000">2、TCO2014 Round 3B Div1 1000</h3>
<p>给定长度为 <span class="math inline">\(N-1\)</span> 的数组 <span class="math inline">\(p\)</span> 以及整数 <span class="math inline">\(K\)</span>，设无根树 <span class="math inline">\(T=(V,E)\)</span> 满足 <span class="math inline">\(V=[0,N)\cap\mathbf{N}\)</span>，<span class="math inline">\(E=\{(p[i],i+1)|i\in\mathbf{N},i &lt; N-1\}\)</span>，求有多少个无根树 <span class="math inline">\(T&#39;=(V&#39;,E&#39;)\)</span> 满足 <span class="math inline">\(V&#39;=V\)</span> 且 <span class="math inline">\(|E|-|E\cap E&#39;|\le K\)</span>。<span class="math inline">\(2\le N\le 50,0\le K\le 50\)</span>。</p>
<p>一开始看题的时候啥思路也没有，一开始从DP的角度考虑，发现树的条件难以用DP阶段来描述，如果强行DP只能状压，复杂度指数级。</p>
<p>正解依旧很神。</p>
<p>首先，考虑这样一个问题：给定带权完全图 <span class="math inline">\(G=(V,E)\)</span>，<span class="math inline">\((u,v)\in E\)</span> 的权值为 <span class="math inline">\(w(u,v)\)</span>，可以认为 <span class="math inline">\(w(u,u)=0\)</span>，设 <span class="math inline">\(ST(G)\)</span> 为 <span class="math inline">\(G\)</span> 的生成树集合，求</p>
<p><span class="math display">\[\sum_{T\in ST(G)}\prod_{(u,v)\in E(T)}w(u,v)\]</span></p>
<p>即经典的<strong>生成树计数</strong>问题。</p>
<p>结论是这样的：记 <span class="math inline">\(n=|V(G)|\)</span>，用自然数 <span class="math inline">\(0,1,...,n-1\)</span> 代替 <span class="math inline">\(V(G)\)</span> 中的节点，构造 <span class="math inline">\((n-1)\times(n-1)\)</span> 矩阵 <span class="math inline">\(A\)</span>，其中</p>
<p><span class="math display">\[A_{i,j}=[i=j]\sum_{k=0}^{n-1}w(i,k)-w(i,j),0\le i,j &lt; n-1\]</span></p>
<p>那么 <span class="math inline">\(\det A\)</span> 即为答案，求解模意义下的高斯消元即可在 <span class="math inline">\(O(n^3)\)</span> 时间内求出其值。证明比较复杂，vfk大神的博客 http://vfleaking.blog.163.com/blog/static/1748076342013112523651955/ 有详细的证明。</p>
<p>现在我们来做一件事情：随便设一个数 <span class="math inline">\(x\)</span>，然后构造一个完全图 <span class="math inline">\(G=(V,E_G)\)</span>，对于 <span class="math inline">\((u,v)\in E_G\)</span>，定义</p>
<p><span class="math display">\[w(u,v)=\begin{cases}1,&amp;(u,v)\in E\\ x&amp;(u,v)\not\in E\end{cases}\]</span></p>
<p>说白了就是把完全图中<strong>属于树 <span class="math inline">\(T\)</span> 的边权设为 <span class="math inline">\(1\)</span>，不属于树 <span class="math inline">\(T\)</span> 的边权设为 <span class="math inline">\(x\)</span></strong>。然后对于一个 <span class="math inline">\(G\)</span> 的生成树 <span class="math inline">\(T&#39;=(V,E&#39;)\)</span>，设 <span class="math inline">\(k=|E|-|E\cap E&#39;|\)</span>，那么 <span class="math inline">\(\prod{(u,v)\in E&#39;}w(u,v)\)</span> 的值是多少呢？由于 <span class="math inline">\(T&#39;\)</span> 中有 <span class="math inline">\(k\)</span> 条边不属于 <span class="math inline">\(T\)</span>，所以，很显然，这个式子的值是 <span class="math inline">\(x^k\)</span>。</p>
<p>那么 <span class="math inline">\(\sum_{T\in ST(G)}\prod_{(u,v)\in E(T)}w(u,v)\)</span> 是一个关于 <span class="math inline">\(x\)</span> 的多项式 <span class="math inline">\(a_0+a_1x+a_2x^2+...+a_{N-1}x^{N-1}\)</span>，其中 <span class="math inline">\(a_i\)</span> 为满足 <span class="math inline">\(|E|-|E\cap E&#39;|=i\)</span> 的无根树 <span class="math inline">\(T&#39;\)</span> 的数目。这里的问题解决方法思想类似于<strong>待定系数法</strong>，通过把 <span class="math inline">\(x=0,1,2,...,N-1\)</span> 的值代入求出 <span class="math inline">\(\det A\)</span>，就能得到关于 <span class="math inline">\(a_0,a_1,...,a_{N-1}\)</span> 的一个方程组，用高斯消元解方程组即可求出每个 <span class="math inline">\(a_i\)</span>，问题得以解决。</p>
<p>因为把每个 <span class="math inline">\(x\)</span> 代入求 <span class="math inline">\(\det A\)</span> 需要 <span class="math inline">\(O(N^3)\)</span> 的时间，所以总复杂度为 <span class="math inline">\(O(N^4)\)</span>。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeDistance</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">50</span>][<span class="number">50</span>],b[<span class="number">50</span>],x[<span class="number">50</span>];</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> p=MOD)</span></span>&#123;<span class="keyword">return</span> a==<span class="number">1</span>?<span class="number">1</span>:(<span class="number">1</span>+p*(a-inv(p%a,a)))/a%p;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">det</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> D=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j,t;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=i;j&lt;n&amp;&amp;!a[j][i];j++);</span><br><span class="line">            <span class="keyword">if</span>(j==n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;n;k++)t=a[i][i],a[i][i]=a[j][i],a[j][i]=t;</span><br><span class="line">            t=b[i];b[i]=b[j];b[j]=t;</span><br><span class="line">            D=D*(j==i?a[i][i]:MOD-a[i][i])%MOD;</span><br><span class="line">            <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)<span class="keyword">if</span>(a[j][i])&#123;</span><br><span class="line">                t=(MOD-a[j][i])*inv(a[i][i])%MOD;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;n;k++)a[j][k]=(a[j][k]+<span class="number">1l</span>l*a[i][k]*t)%MOD;</span><br><span class="line">                b[j]=(b[j]+<span class="number">1l</span>l*b[i]*t)%MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> D;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countTrees</span><span class="params">(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; p, <span class="keyword">int</span> K)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=p.size(),N=n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;N;t++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)a[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>,z;j&lt;N;j++)z=i&amp;&amp;p[i<span class="number">-1</span>]==j||j&amp;&amp;p[j<span class="number">-1</span>]==i?<span class="number">1</span>:t,(a[i][j]+=MOD-z)%=MOD,(a[j][i]+=MOD-z)%=MOD,(a[i][i]+=z)%=MOD,(a[j][j]+=z)%=MOD;</span><br><span class="line">            x[t]=det(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;b[i]=x[i],i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=*a[i]=<span class="number">1</span>;j&lt;N;j++)a[i][j]=<span class="number">1l</span>l*a[i][j<span class="number">-1</span>]*i%MOD;</span><br><span class="line">        det(N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=N,j;i--;x[i]=x[i]*inv(a[i][i])%MOD)</span><br><span class="line">            <span class="keyword">for</span>(x[i]=b[i],j=N;--j&gt;i;)x[i]=(x[i]+<span class="number">1l</span>l*(MOD-a[i][j])*x[j])%MOD;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N&amp;&amp;i&lt;=K;i++)(s+=x[i])%=MOD;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="#top">返回顶部</a></p>
<hr>
<h3 id="codeforces-722e">3、Codeforces 722E</h3>
<p>给定 <span class="math inline">\(n\times m\)</span> 的网格图和图中一个大小为 <span class="math inline">\(k\)</span> 的格子集合 <span class="math inline">\(S\)</span>，再给定正整数 <span class="math inline">\(s\)</span>。现在从所有<strong>从网格图的左上角走到右下角，每一步只往下或往右走一格的路径</strong>中随机选取一条，然后沿着这条路径走，每次经过属于 <span class="math inline">\(S\)</span> 的格子时，修改 <span class="math inline">\(s\leftarrow\lceil\frac{s}{2}\rceil\)</span>。求到达右下角时 <span class="math inline">\(s\)</span> 的值的期望除以 <span class="math inline">\(1,000,000,007\)</span> 的余数，即 <span class="math inline">\(E(s)\bmod 1,000,000,007\)</span>。显然 <span class="math inline">\(E(s)\)</span> 是一个有理数。<span class="math inline">\(1\le n, m\le 100,000, 0\le k\le 2,000, 1\le s\le 1,000,000\)</span>。</p>
<p>http://codeforces.com/problemset/problem/722/E</p>
<p>这场比赛我也参加过，也打挂了……主要就是因为这题花了太多时间，然而没有做出来。</p>
<p>这道题我想复杂掉坑了，只想出了 <span class="math inline">\(O(k^3\log s)\)</span> 的做法，过不了，然后一直想着怎么去优化这个算法，结果失败了。为什么掉坑了？因为之前做过一道求不经过 <span class="math inline">\(S\)</span> 中的格子的路径条数，我用的是容斥原理来解决，因此觉得这题只能用容斥原理……</p>
<p>我的思路是这样的：设 <span class="math inline">\(f_A\)</span> 为所有路径中，经过的 <span class="math inline">\(S\)</span> 中的格子的集合恰好为 <span class="math inline">\(A\)</span> 的路径条数，<span class="math inline">\(g_A\)</span> 为所有路径中，经过了集合 <span class="math inline">\(A\)</span> 中的所有格子的路径条数。那么显然有 <span class="math inline">\(g_A=\sum_{B\subseteq S,B\supseteq A}f_B\)</span>。这样是指数级的，我们只需要知道经过的格子个数即可，因此记 <span class="math inline">\(f&#39;_i=\sum_{A\subseteq S,|A|=i}f_A,g&#39;_i=\sum_{A\subseteq S,|A|=i}g_A\)</span>，则</p>
<p><span class="math display">\[g&#39;_i=\sum_{A\subseteq S,|A|=i}\sum_{B\subseteq S,B\supseteq A}f_B=\sum_{B\subseteq S}f_B\sum_{A\subseteq B,|A|=i}1=\sum_{B\subseteq S}C_{|B|}^if_B=\sum_{j=i}^kC_j^i\sum_{B\subseteq S,|B|=j}f_B=\sum_{j=i}^kC_j^if&#39;_j\]</span></p>
<p>从而可以得到容斥的式子 <span class="math inline">\(f&#39;_i=\sum_{j=i}^kC_j^i(-1)^{j-i}g&#39;_j\)</span>.</p>
<p>同时 <span class="math inline">\(g&#39;_i\)</span> 可以用DP求出：记 <span class="math inline">\(g(i,j)\)</span> 为以 <span class="math inline">\(i\in S\)</span> 为起点，右下角为终点时，对于所有 <span class="math inline">\(S\)</span> 的大小为 <span class="math inline">\(j\)</span> 的子集 <span class="math inline">\(A\)</span>，从 <span class="math inline">\(i\)</span> 到终点经过子集 <span class="math inline">\(A\)</span> 中的所有格子到终点的路径条数之和，则 <span class="math inline">\(g(i,0)=C_{n-r_i+m-c_i}^{n-r_i}\)</span>，当 <span class="math inline">\(j &gt; 0\)</span> 时</p>
<p><span class="math display">\[g(i,j)=\sum_{r_{i&#39;}\ge r_i,c_{i&#39;}\ge c_i,i&#39;\ne i}C_{r_{i&#39;}-r_i+c_{i&#39;}-c_i}^{r_{i&#39;}-r_i}g(i&#39;,j-1)\]</span></p>
<p>这里我们把左上角格 <span class="math inline">\(s\)</span> 加入 <span class="math inline">\(S\)</span>，那么 <span class="math inline">\(g&#39;_i=g(s,i)\)</span>，这样就能得到所有 <span class="math inline">\(f&#39;_i\)</span>，答案就是 <span class="math inline">\(1+\frac{1}{C_{n+m-2}^{n-1}}\sum_{i=0}^kf&#39;_i\lfloor\frac{s-1}{2^i}\rfloor\)</span>。</p>
<p>问题来了！<span class="math inline">\(g(i,j)\)</span> 的状态数是 <span class="math inline">\(O(k^2)\)</span>，每个状态转移数为 <span class="math inline">\(O(k)\)</span>，总转移数为 <span class="math inline">\(O(k^3)\)</span>，无法通过！虽然注意到答案中 <span class="math inline">\(f&#39;_i\)</span> 的 <span class="math inline">\(i\)</span> 这一维只用到了 <span class="math inline">\(\log_2s\)</span>，但是计算 <span class="math inline">\(f&#39;_i\)</span> 所用到的 <span class="math inline">\(g&#39;_j\)</span> 的 <span class="math inline">\(j\)</span> 到了 <span class="math inline">\(k\)</span> 级别。怎么优化呢？我一直觉得很容易优化，但尝试多种思路之后以失败告终。</p>
<p>最后去看了题解……</p>
<p>首先题目说不经过任何一个 <span class="math inline">\(S\)</span> 中的格子的路径条数可以用 <span class="math inline">\(g(i)=C_{n-r_i+m-c_i}^{n-r_i}-\sum_{j\ne i}C_{r_j-r_i+c_j-c_i}^{r_j-r_i}g(j)\)</span> 来递推，这其实就是之前的容斥原理。问题是题解并没有用到容斥啊！那这是由什么依据得到的？枚举第一个经过的点？</p>
<p>如果从 <span class="math inline">\(i\)</span> 出发第一个到 <span class="math inline">\(j\)</span>，那么 <span class="math inline">\(i\)</span> 到 <span class="math inline">\(j\)</span> 这一段不能经过别的 <span class="math inline">\(S\)</span> 中的点，这个好像也不能预处理……继续不知所措。</p>
<p>继续对着式子理解才发现——原来枚举的是最后一个经过的点！</p>
<p>是啊，既然枚举第一个经过的点不可行，那我们就用逆向思维：枚举最后一个经过的点就可以啦！</p>
<p>求从 <span class="math inline">\(i\)</span> 出发至少经过一个 <span class="math inline">\(S\)</span> 中的点的路径条数，枚举最后一个经过的点 <span class="math inline">\(j\)</span>，那么 <span class="math inline">\(i\)</span> 到 <span class="math inline">\(j\)</span> 可以任意走，<span class="math inline">\(j\)</span> 到终点不能经过 <span class="math inline">\(S\)</span> 中的点。类似的，原来的问题也很好解决了：设 <span class="math inline">\(f(i,j)\)</span> 为从 <span class="math inline">\(i\)</span> 出发经过恰好 <span class="math inline">\(j\)</span> 个 <span class="math inline">\(S\)</span> 中的点的方案数，首先一共有 <span class="math inline">\(C_{n-r_i+m-c_i}\)</span> 条路径，其中，计算经过超过 <span class="math inline">\(j\)</span> 个 <span class="math inline">\(S\)</span> 中的点的方案数，可以枚举倒数第 <span class="math inline">\(j+1\)</span> 个点 <span class="math inline">\(i&#39;\)</span>，方案数为 <span class="math inline">\(C_{r_{i&#39;}-r_i+c_{i&#39;}-c_i}^{r_{i&#39;}-r_i}f(i&#39;,j-1)\)</span>，从总路径数减掉超过 <span class="math inline">\(j\)</span> 个点的路径数以后，再减掉少于 <span class="math inline">\(j\)</span> 个点的，即 <span class="math inline">\(\sum_{j&#39;=0}^{j-1}f(i,j&#39;)\)</span>。于是我们得到了递推式：</p>
<p><span class="math display">\[f(i,j)=C_{n-r_i+m-c_i}-\sum_{i&#39;\ne i}C_{r_{i&#39;}-r_i+c_{i&#39;}-c_i}^{r_{i&#39;}-r_i}f(i&#39;,j-1)-\sum_{j&#39;=0}^{j-1}f(i,j&#39;)\]</span></p>
<p>设左上角为 <span class="math inline">\(s\)</span>，则 <span class="math inline">\(f&#39;_i=f(s,i)\)</span>，用之前计算答案的式子计算即可。状态数优化到了 <span class="math inline">\(O(k\log s)\)</span>，复杂度 <span class="math inline">\(O(k^2\log s)\)</span>。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">int</span> n,m,k,s,r[<span class="number">2010</span>],c[<span class="number">2010</span>];</span><br><span class="line">ll fac[<span class="number">200010</span>],ifac[<span class="number">200010</span>],f[<span class="number">2010</span>][<span class="number">21</span>];</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> a==<span class="number">1</span>?<span class="number">1</span>:(<span class="number">1</span>+p*(a-inv(p%a,a)))/a%p;&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[i][j])<span class="keyword">return</span> f[i][j]<span class="number">-1</span>;</span><br><span class="line">	f[i][j]=fac[n+m-r[i]-c[i]]*ifac[n-r[i]]%MOD*ifac[m-c[i]]%MOD;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> t=j;t--;)(f[i][j]+=MOD-dfs(i,t))%=MOD;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> t=k;t--;)<span class="keyword">if</span>(t!=i&amp;&amp;r[t]&gt;=r[i]&amp;&amp;c[t]&gt;=c[i])(f[i][j]+=(MOD-fac[r[t]+c[t]-r[i]-c[i]])*ifac[r[t]-r[i]]%MOD*ifac[c[t]-c[i]]%MOD*dfs(t,j))%=MOD;</span><br><span class="line">	<span class="keyword">return</span> f[i][j]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;k,&amp;s);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,r+i,c+i);</span><br><span class="line">	r[k]=c[k]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=*fac=<span class="number">1</span>;i&lt;=n+m;i++)fac[i]=fac[i<span class="number">-1</span>]*i%MOD;</span><br><span class="line">	ifac[n+m]=inv(fac[n+m],MOD);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n+m;i--;)ifac[i]=ifac[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%MOD;</span><br><span class="line">	ll ans=<span class="number">0</span>;s--;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;s;j++,s/=<span class="number">2</span>)(ans+=dfs(k,j)*s)%=MOD; </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;(ans*ifac[n+m<span class="number">-2</span>]%MOD*fac[n<span class="number">-1</span>]%MOD*fac[m<span class="number">-1</span>]+<span class="number">1</span>)%MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实问题比我想象的简单得多，完全没有必要用到容斥之类的复杂算法，这也说明思考问题不能局限于一种思路。比如统计“不含 <span class="math inline">\(S\)</span>”的方案数时，可以用容斥，也可以用总的方案数减去至少含一个 <span class="math inline">\(S\)</span> 的方案数，而后者可以枚举第一个 <span class="math inline">\(S\)</span> 中的元素，等等。</p>
<p><a href="#top">返回顶部</a></p>
<hr>
<h3 id="codeforces-713d">4、Codeforces 713D</h3>
<p>给定 <span class="math inline">\(n\times m\)</span> 的01矩阵 <span class="math inline">\(a_{i,j}\)</span>（<span class="math inline">\(1\le i\le n,1\le j\le m,0\le a_{i,j}\le 1\)</span>），再给出 <span class="math inline">\(t\)</span> 组询问，每组询问给出四个整数 <span class="math inline">\(x_1,y_1,x_2,y_2\)</span>（<span class="math inline">\(1\le x_1\le x_2\le n,1\le y_1\le y_2\le m\)</span>），求第 <span class="math inline">\(x_1\)</span> 至 <span class="math inline">\(x_2\)</span> 行第 <span class="math inline">\(y_1\)</span> 至第 <span class="math inline">\(y_2\)</span> 列的最大全1子<strong>正方形</strong>大小，形式化地，求一个最大的 <span class="math inline">\(b\)</span>，使得存在整数 <span class="math inline">\(x,y\)</span> 使得 <span class="math inline">\(x,x+b-1\in[x_1,x_2]\)</span>，<span class="math inline">\(y,y+b-1\in[y_1,y_2]\)</span>，且 <span class="math inline">\(\forall x&#39;\in\{x,x+1,...,x+b-1\},y&#39;\in\{y,y+1,...,y+b-1\},a_{x&#39;,y&#39;}=1\)</span>。<span class="math inline">\(1\le n,m\le 1,000\)</span>，<span class="math inline">\(t\le 1,000,000\)</span>。</p>
<p>http://codeforces.com/problemset/problem/713/D</p>
<p>考场上因为没时间所以没看这题，后来看这题的时候想了很久，并没有想出什么靠谱的做法。</p>
<p>我的想法是，首先如果是单次询问，可以DP求出最大的子正方形：<span class="math inline">\(f(x,y)\)</span> 表示以 <span class="math inline">\((x,y)\)</span> 为左上角的最大全1子正方形大小，那么</p>
<p><span class="math display">\[f(x,y)=\begin{cases}0,&amp;a_{x,y}=0,\\ \max\{f(x,y+1),f(x+1,y),f(x+1,y+1)\}+1,&amp;a_{x,y}=1.\end{cases}\]</span></p>
<p>既然询问次数 <span class="math inline">\(t\)</span> 这么大，就不能每次求一遍DP，那么子矩阵的DP值有没什么性质呢？然后我发现，设 <span class="math inline">\(f&#39;(x,y)\)</span> 为询问子矩形内以 <span class="math inline">\((x,y)\)</span> 为左上角的最大全1子正方形大小，则</p>
<p><span class="math display">\[f&#39;(x,y)=\min\{f(x,y),x_2-x+1,y_2-y+1\}\]</span></p>
<p>接着，我想用一些数据结构来维护上面这个式子的值，然而似乎各种数据结构都维护不了。还尝试着把每个格子和它的 <span class="math inline">\(f(x,y)\)</span> 表示成一个三维点，然后维护不同的区域的点权最大值——但是并不可做。</p>
<p>看完题解发现这题并不难，是我自己太傻逼了没想到做法。</p>
<p>这种最大化最小值（即 <span class="math inline">\(\min\{f(x,y),|x_2-x+1|,|y_2-y+1|\}\)</span>）的题，显然要想到二分啊！二分一个 <span class="math inline">\(b\)</span>，然后判定是否存在 <span class="math inline">\(x,y\)</span> 使得 <span class="math inline">\(x_1\le x\le x_2,y_1\le y\le y_2,\min\{f(x,y),x_2-x+1,y_2-y+1\}\ge b\)</span>，即</p>
<p><span class="math display">\[\begin{cases}x_1\le x\le x_2-b+1 \\ y_1\le y\le y_2-b+1 \\ f(x,y)\ge b\end{cases}\]</span></p>
<p>只需查询子矩形内的 <span class="math inline">\(f(x,y)\)</span> 最大值即可，这是一个二维RMQ问题，使用Sparse Table即可用 <span class="math inline">\(O(nm\log n\log m)\)</span> 的时间预处理，每次 <span class="math inline">\(O(1)\)</span> 的时间查询。</p>
<p>由于每次询问要二分，所以总复杂度就是 <span class="math inline">\(O(nm\log n\log m+t\log\min\{n,m\})\)</span>。代码如下（为了节省内存，我开了 <code>short</code>）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> g f[x][y]</span></span><br><span class="line"><span class="keyword">short</span> f[<span class="number">1001</span>][<span class="number">1001</span>][<span class="number">10</span>][<span class="number">10</span>],<span class="built_in">log</span>[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">min</span><span class="params">(<span class="keyword">short</span> x,<span class="keyword">short</span> y)</span></span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">max</span><span class="params">(<span class="keyword">short</span> x,<span class="keyword">short</span> y)</span></span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m,t,x1,y1,x2,y2,N;<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);N=n&gt;m?n:m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;n;x++)<span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;m;y++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t),**f[x][y]=t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)<span class="built_in">log</span>[i]=<span class="built_in">log</span>[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x=n;x--;)<span class="keyword">for</span>(<span class="keyword">int</span> y=m;y--;)&#123;</span><br><span class="line">		<span class="keyword">if</span>(**g)**g=<span class="number">1</span>+min(min(**f[x][y+<span class="number">1</span>],**f[x+<span class="number">1</span>][y]),**f[x+<span class="number">1</span>][y+<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="built_in">log</span>[n];i++)<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="built_in">log</span>[m];j++)g[i][j]=j?max(g[i][j<span class="number">-1</span>],y+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)&lt;m?f[x][y+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][i][j<span class="number">-1</span>]:<span class="number">0</span>):i?max(g[i<span class="number">-1</span>][j],x+(<span class="number">1</span>&lt;&lt;i<span class="number">-1</span>)&lt;n?f[x+(<span class="number">1</span>&lt;&lt;i<span class="number">-1</span>)][y][i<span class="number">-1</span>][j]:<span class="number">0</span>):g[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);t--;)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);x1--;y1--;</span><br><span class="line">		<span class="keyword">int</span> L=<span class="number">0</span>,R=min(x2-x1,y2-y1)+<span class="number">1</span>,M,i,j;</span><br><span class="line">		<span class="keyword">while</span>(R-L&gt;<span class="number">1</span>)M=L+R&gt;&gt;<span class="number">1</span>,i=<span class="built_in">log</span>[x2-x1-M+<span class="number">1</span>],j=<span class="built_in">log</span>[y2-y1-M+<span class="number">1</span>],max(max(f[x1][y1][i][j],f[x1][y2-M+<span class="number">1</span>-(<span class="number">1</span>&lt;&lt;j)][i][j]),max(f[x2-M+<span class="number">1</span>-(<span class="number">1</span>&lt;&lt;i)][y1][i][j],f[x2-M+<span class="number">1</span>-(<span class="number">1</span>&lt;&lt;i)][y2-M+<span class="number">1</span>-(<span class="number">1</span>&lt;&lt;j)][i][j]))&lt;M?R=M:L=M;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,L);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题一开始的时候把一个 <code>y1</code> 打成了 <code>y2</code>，导致样例通过然而提交之后WA。后来通过自己手工测试小数据就发现了这个问题。所以，以后在Codeforces这种无法花太多时间对拍的比赛时务必多测试几组手构的数据。</p>
<p><a href="#top">返回顶部</a></p>
<hr>
<h3 id="codeforces-762f">5、Codeforces 762F</h3>
<p>给定无根树 <span class="math inline">\(S,T\)</span>，求有多少个 <span class="math inline">\(S\)</span> 的连通子图 <span class="math inline">\(G\)</span> 与 <span class="math inline">\(T\)</span> 同构，答案对 <span class="math inline">\(10^9+7\)</span> 取模。图 <span class="math inline">\(G\)</span> 与 <span class="math inline">\(T\)</span> 同构当且仅当存在一个满单射 <span class="math inline">\(f:V(G)\rightarrow V(T)\)</span> 使得 <span class="math inline">\(\forall (u,v)\in E(G),(f(u),f(v))\in E(T)\)</span>。</p>
<p>用 <span class="math inline">\(|S|,|T|\)</span> 表示 <span class="math inline">\(S,T\)</span> 的节点数，<span class="math inline">\(|S|\le 1,000\)</span>，<span class="math inline">\(|T|\le 12\)</span>。</p>
<p>http://codeforces.com/problemset/problem/762/F</p>
<p>这题是前几天Educational Round的题，我作为未参加比赛的场外选手围观了一下，发现这题看起来挺简单，于是就准备直接上树形DP：任取 <span class="math inline">\(S\)</span> 中的节点作为根，然后枚举 <span class="math inline">\(G\)</span> 中深度最小的点 <span class="math inline">\(u\)</span>，接着枚举 <span class="math inline">\(T\)</span> 的根 <span class="math inline">\(v\)</span>，令 <span class="math inline">\(f(u)=v\)</span>，接着就可以设计一个DP了？<span class="math inline">\(f(u,v)\)</span> 表示 <span class="math inline">\(S_u\)</span> 取一个连通子图和 <span class="math inline">\(T_v\)</span> 同构的方案数（这里 <span class="math inline">\(S_u\)</span> 表示 <span class="math inline">\(S\)</span> 中以 <span class="math inline">\(u\)</span> 为根的子树，<span class="math inline">\(T_v\)</span> 意思类似），那么就是枚举每个 <span class="math inline">\(v\)</span> 的子节点 <span class="math inline">\(c_v\in C_v\)</span> 和哪个 <span class="math inline">\(u\)</span> 的子节点 <span class="math inline">\(c_u\in C_u\)</span> 配对，<strong>也就是枚举 <span class="math inline">\(C_v\rightarrow C_u\)</span> 的所有可能的映射</strong>，答案乘上 <span class="math inline">\(f(c_u,c_v)\)</span>，所有乘积加起来就好了？（<span class="math inline">\(C_u\)</span> 表示 <span class="math inline">\(u\)</span> 的子节点集合，<span class="math inline">\(C_v\)</span> 类似）</p>
<p><span class="math display">\[f(u,v)=\sum_{g:C_v\rightarrow C_u,\forall p\ne q,g(p)\ne g(q)}\prod_{p\in C_v}f(g(p),p)\]</span></p>
<p>但当我写完这个式子以后发现是错的，因为这样会算重复。比如 <span class="math inline">\(S=T=(\{1,2,3\},\{(1,2),(1,3)\})\)</span>，那么 <span class="math inline">\(g(2)=2,g(3)=3\)</span> 和 <span class="math inline">\(g(2)=3,g(3)=2\)</span> 算了两次，导致 <span class="math inline">\(f(1,1)=2\)</span>，但是 <span class="math inline">\(S\)</span> 与 <span class="math inline">\(T\)</span> 同构的子图只有 <span class="math inline">\(S\)</span> 本身一个。</p>
<p>怎么办呢？当时想能否不枚举映射而枚举子集，这样就能满足定义，然而枚举了子集却无法转移，因为就不知道哪个子树和哪个子树对应。</p>
<p>于是就不会了……接着又想了一会儿，发现了一种一直被我忽略的思路。</p>
<p>如果强行按照上面这种“错误算法”来算，那么算出来的是啥？很显然，就是所有从 <span class="math inline">\(S\)</span> 中选出 <span class="math inline">\(|T|\)</span> 个节点标上标号 <span class="math inline">\(1,2,...,|T|\)</span>，使得对任意 <span class="math inline">\((u,v)\in T\)</span>，<span class="math inline">\(S\)</span> 中标号 <span class="math inline">\(u,v\)</span> 的两点必有一条边相连。</p>
<p>然后我们要求的答案是啥？是选出 <span class="math inline">\(S\)</span> 中的 <span class="math inline">\(|T|\)</span> 个节点，使得它的导出子图与 <span class="math inline">\(T\)</span> 同构。</p>
<p>如果用“错误算法”选出了一个大小为 <span class="math inline">\(|T|\)</span> 的子集，它和 <span class="math inline">\(T\)</span> 是不同构的，那么它有几种标号方案？显然是 <span class="math inline">\(0\)</span>，根据定义显然。</p>
<p>如果是同构的呢？这就相当于有两个完全相同的树 <span class="math inline">\(T_1,T_2\)</span>，要求把 <span class="math inline">\(T_2\)</span> 中的所有节点 <span class="math inline">\(v\)</span> 重新编号为 <span class="math inline">\(f(v)\)</span>（<span class="math inline">\(f\)</span> 是 <span class="math inline">\(V(T)\)</span> 的一个满单射），使得 <span class="math inline">\(\forall (u,v)\in E(T_1),(f(u),f(v))\in E(T_2)\)</span>。<strong>也就是标号方案数只和 <span class="math inline">\(T\)</span> 有关。</strong>我们用 <span class="math inline">\(K\)</span> 表示这样的标号方案数。</p>
<p>这样，如果答案是 <span class="math inline">\(I\)</span>，那么“错误算法”求出的答案就是 <span class="math inline">\(IK\bmod(10^9+7)\)</span>。而 <span class="math inline">\(K\)</span> 显然是可以用同样的“错误算法”求出来的。</p>
<p>并且由于 <span class="math inline">\(|T|\le 12\)</span>，可得 <span class="math inline">\(1\le K\le 12! &lt; 10^9+7\)</span>，因此 <span class="math inline">\(K\)</span> 在模 <span class="math inline">\(10^9+7\)</span> 意义下有逆元，把错误的答案乘上 <span class="math inline">\(K\)</span> 就能得到正确的答案了。</p>
<p>现在的算法就明确了，枚举 <span class="math inline">\(T\)</span> 的根 <span class="math inline">\(v\)</span>，然后做一遍上述的DP，计算出答案 <span class="math inline">\(\mathrm{ans}(S,T)=\sum_{u\in V(S)}f(u,v)\)</span>；之后把 <span class="math inline">\(S\)</span> 换成 <span class="math inline">\(T\)</span> 再做一遍求出 <span class="math inline">\(\mathrm{ans}(T,T)\)</span>，答案就是 <span class="math inline">\(\mathrm{ans}(S,T)\cdot\mathrm{ans}(T,T)^{-1}\pmod{10^9+7}\)</span>。</p>
<p>然而DP还需要优化，因为求 <span class="math inline">\(f(u,v)\)</span> 时不能暴力枚举所有 <span class="math inline">\(C_v\rightarrow C_u\)</span> 的映射。我们可以用一个辅助的状压DP，记 <span class="math inline">\(f&#39;(i,V)\)</span> 为将 <span class="math inline">\(V\)</span> 用 <span class="math inline">\(g\)</span> 映射到 <span class="math inline">\(u\)</span> 的前 <span class="math inline">\(i\)</span> 个子节点的 <span class="math inline">\(\prod_{v}f(g(v),v)\)</span> 的和，枚举第 <span class="math inline">\(i\)</span> 个子节点 <span class="math inline">\(c_i\)</span> 是否被 <span class="math inline">\(V\)</span> 中的点映射，以及被 <span class="math inline">\(V\)</span> 中哪一个点映射，即可得到</p>
<p><span class="math display">\[f&#39;(i,V)=f&#39;(i-1,V)+\sum_{j\in V}f&#39;(i-1,V-\{j\})f(c_i,j)\]</span></p>
<p>这样对于 <span class="math inline">\(T\)</span> 的每一个根，DP复杂度就是 <span class="math inline">\(O(|S||T|\cdot 2^{|T|})\)</span>，总复杂度 <span class="math inline">\(O(|S||T|^2\cdot 2^{|T|})\)</span>，实际上已经可以通过了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> to;edge*next;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> n,ch[<span class="number">1001</span>][<span class="number">1001</span>],ccnt[<span class="number">1001</span>],cset[<span class="number">1001</span>];</span><br><span class="line">	edge E[<span class="number">2000</span>],*ne,*first[<span class="number">1001</span>];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;*ne=(edge)&#123;v,first[u]&#125;;first[u]=ne++;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);ne=E;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v),link(u,v),link(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> c=cset[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(edge*e=first[i];e;e=e-&gt;next)</span><br><span class="line">			<span class="keyword">if</span>(e-&gt;to!=f)dfs(ch[i][c++]=e-&gt;to,i),cset[i]|=<span class="number">1</span>&lt;&lt;e-&gt;to<span class="number">-1</span>;</span><br><span class="line">		ccnt[i]=c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;S,T;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1001</span>][<span class="number">1</span>&lt;&lt;<span class="number">12</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!j)<span class="keyword">return</span>!V;</span><br><span class="line">	<span class="keyword">int</span>&amp;s=f[S.ch[i][j<span class="number">-1</span>]][V];</span><br><span class="line">	<span class="keyword">if</span>(s)<span class="keyword">return</span> s<span class="number">-1</span>;</span><br><span class="line">	s=dfs(i,j<span class="number">-1</span>,V);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> c=S.ch[i][j<span class="number">-1</span>],k=<span class="number">0</span>;k&lt;T.n;k++)</span><br><span class="line">		<span class="keyword">if</span>(V&gt;&gt;k&amp;<span class="number">1</span>)s=(s+<span class="number">1l</span>l*dfs(i,j<span class="number">-1</span>,V-(<span class="number">1</span>&lt;&lt;k))*dfs(c,S.ccnt[c],T.cset[k+<span class="number">1</span>]))%MOD;</span><br><span class="line">	<span class="keyword">return</span> s++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> a==<span class="number">1</span>?<span class="number">1</span>:(<span class="number">1</span>+p*(a-inv(p%a,a)))/a%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	S.read();T.read();</span><br><span class="line">	S.dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">1</span>;r&lt;=T.n;r++)&#123;</span><br><span class="line">		T.dfs(r,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=S.n;i++)ans=(ans+dfs(i,S.ccnt[i],T.cset[r]))%MOD;</span><br><span class="line">		<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">	&#125;</span><br><span class="line">	S=T;</span><br><span class="line">	S.dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> ans2=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">1</span>;r&lt;=T.n;r++)&#123;</span><br><span class="line">		T.dfs(r,<span class="number">0</span>);</span><br><span class="line">		ans2=(ans2+dfs(<span class="number">1</span>,S.ccnt[<span class="number">1</span>],T.cset[r]))%MOD;</span><br><span class="line">		<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f[<span class="number">0</span>])*<span class="number">13</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ans=ans*inv(ans2,MOD)%MOD;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我一开始提交的时候WA了，经过检查枚举 <span class="math inline">\(T\)</span> 的根 <code>r</code> 时，<code>f</code> 数组忘记每次清空，于是加了一个 <code>memset</code> 清空数组，然而交上去再次WA，因为前面一个循环加了后面一个循环忘了加= =b</p>
<p>后来 immortalCO 告诉我他的做法，不用枚举 <span class="math inline">\(T\)</span> 的根，而是在DP中记边的信息，即记 <span class="math inline">\(f(u,e)\)</span> 表示 <span class="math inline">\(S\)</span> 的 <span class="math inline">\(u\)</span> 子树和 <span class="math inline">\(T\)</span> 中由 <span class="math inline">\(e\)</span> 这条边指向的子树的匹配方案数，这样复杂度就少一个 <span class="math inline">\(|T|\)</span> 了。</p>
<p><a href="#top">返回顶部</a></p>
<hr>
<h3 id="uoj-54">6、UOJ #54</h3>
<p>求有多少种方案从 <span class="math inline">\(n\)</span> 维空间中选取 <span class="math inline">\(c\)</span> 个点，每个点的第 <span class="math inline">\(i\)</span> 维坐标为不超过 <span class="math inline">\(m_i\)</span> 的正整数，对于每一维坐标所有点的坐标严格递增，且 <span class="math inline">\(c\)</span> 个点共线。详细题意及数据规模见题目链接。</p>
<p>http://uoj.ac/problem/54</p>
<p>这题是我去年就思考过的一个问题。<span class="math inline">\(n\)</span> 维空间比较抽象，因此先从 <span class="math inline">\(2\)</span> 维空间开始考虑。一种容易入手的思路是这样的：枚举第一个点 <span class="math inline">\(P_1\)</span> 和最后一个点 <span class="math inline">\(P_c\)</span>，那么需要在线段 <span class="math inline">\(P_1P_c\)</span>（除去 <span class="math inline">\(P_1,P_c\)</span> 两点）上取 <span class="math inline">\(c-2\)</span> 个整点 <span class="math inline">\(P_2,...,P_{c-1}\)</span>。设 <span class="math inline">\(P_i(x_i,y_i)\)</span>，则点 <span class="math inline">\(P_i\)</span> 在直线 <span class="math inline">\(P_1P_c\)</span> 上的条件是 <span class="math inline">\((x_c-x_1)(y_i-y_1)=(y_c-y_1)(x_i-x_1)\)</span>，记 <span class="math inline">\(g=\gcd(x_c-x_1,y_c-y_1)\)</span>，那么方程的通解是 <span class="math inline">\(x_i=x_1+\frac{x_c-x_i}{g}t,y_i=y_1+\frac{y_c-y_i}{g}t,t\in\mathbf{Z}\)</span>。<span class="math inline">\(P_i\)</span> 在线段 <span class="math inline">\(P_1P_c\)</span> 上还需要多一个条件 <span class="math inline">\(x_1 &lt; x_i &lt; x_c\)</span>，即 <span class="math inline">\(0 &lt; t &lt; g\)</span>。因此如果已经确定 <span class="math inline">\(P_1,P_c\)</span>，那么线段 <span class="math inline">\(P_1P_c\)</span>（除去 <span class="math inline">\(P_1,P_c\)</span> 两点）上有 <span class="math inline">\(g-1\)</span> 个整点，因此再取 <span class="math inline">\(c-2\)</span> 个整点有 <span class="math inline">\(C_{g-1}^{c-2}\)</span> 种方案，其中 <span class="math inline">\(g=\gcd(x_c-x_1,y_c-y_1)\)</span>。</p>
<p>当然枚举 <span class="math inline">\(P_1,P_c\)</span> 太慢，可以枚举 <span class="math inline">\(x=x_c-x_1\)</span> 和 <span class="math inline">\(y=y_c-y_1\)</span>，接下来 <span class="math inline">\(P_1\)</span> 和 <span class="math inline">\(P_c\)</span> 的选取方案数为 <span class="math inline">\((m_1-x)(m_2-y)\)</span>，答案就是 <span class="math inline">\(\sum_{x=1}^{m_1}\sum_{y=1}^{m_2}(m_1-x)(m_2-y)C_{\gcd(x,y)-1}^{c-2}\)</span>。</p>
<p>这个结论可以推广为 <span class="math inline">\(n\)</span> 维的情形，原理是一致的，答案为：</p>
<p><span class="math display">\[\sum_{x_1=1}^{m_1}(m_1-x_1)\sum_{x_2=1}^{m_2}(m_2-x_2)...\sum_{x_n=1}^{m_n}(m_n-x_n)C_{\gcd(x_1,x_2,...,x_n)}^{c-2}\]</span></p>
<p>这个式子怎么优化计算？之前我研究 <span class="math inline">\(n=2\)</span> 怎么做的时候想到的做法是这样的：构造一个 <span class="math inline">\(m_1\times m_2\)</span> 的表，左上角为 <span class="math inline">\((1,1)\)</span>，右下角为 <span class="math inline">\((m_1,m_2)\)</span>，然后进行 <span class="math inline">\(\min\{m_1,m_2\}\)</span> 轮填数，第 <span class="math inline">\(i\)</span>（<span class="math inline">\(1\le i\le\min\{m_1,m_2\}\)</span>）轮将 <span class="math inline">\(x,y\)</span> 均为 <span class="math inline">\(i\)</span> 的倍数的格子 <span class="math inline">\((x,y)\)</span> 内填入 <span class="math inline">\((m_1-x)(m_2-y)\)</span> 个数 <span class="math inline">\(i\)</span>。填完之后，每个格子 <span class="math inline">\((x,y)\)</span> 内的数的集合就是 <span class="math inline">\(\gcd(x,y)\)</span> 的所有因数，如果能构造一个函数 <span class="math inline">\(f(x)\)</span> 满足对任意 <span class="math inline">\(x\)</span>，有</p>
<p><span class="math display">\[\sum_{d|x}f(d)=C_{x-1}^{c-2}\]</span></p>
<p>那么每个格子 <span class="math inline">\((x,y)\)</span> 内所有数 <span class="math inline">\(x\)</span> 的 <span class="math inline">\(f(x)\)</span> 之和就是 <span class="math inline">\((m_1-x)(m_2-y)C_{\gcd(x,y)-1}^{c-2}\)</span>。考虑填的过程，可得答案为</p>
<p><span class="math display">\[\sum_{i=1}^{\min\{m_1,m_2\}}f(i)\sum_{x=1}^{\lfloor\frac{m_1}{i}\rfloor}(m_1-ix)\sum_{y=1}^{\lfloor\frac{m_2}{i}\rfloor}(m_2-iy)\]</span></p>
<p>化简得到</p>
<p><span class="math display">\[\sum_{i=1}^{\min\{m_1,m_2\}}f(i)\left[m_1\lfloor\frac{m_1}{i}\rfloor-\frac{1}{2}\lfloor\frac{m_1}{i}\rfloor(\lfloor\frac{m_1}{i}\rfloor+1)i\right]\left[m_2\lfloor\frac{m_2}{i}\rfloor-\frac{1}{2}\lfloor\frac{m_2}{i}\rfloor(\lfloor\frac{m_2}{i}\rfloor+1)i\right]\]</span></p>
<p>类似的，可以得到 <span class="math inline">\(n\)</span> 维的情形：</p>
<p><span class="math display">\[\sum_{i=1}^{\min\{m_1,...,m_n\}}f(i)\prod_{j=1}^n\left[m_j\lfloor\frac{m_j}{i}\rfloor-\frac{1}{2}\lfloor\frac{m_j}{i}\rfloor(\lfloor\frac{m_j}{i}\rfloor+1)i\right]\]</span></p>
<p>其中，<span class="math inline">\(f(x)\)</span> 函数可以递推计算：一开始令所有 <span class="math inline">\(f(x)\leftarrow C_{x-1}^{c-2}\)</span>，然后依次对于 <span class="math inline">\(i=1,2,...\)</span>，令所有 <span class="math inline">\(j=2,3,...\)</span> 更新 <span class="math inline">\(f(ij)\leftarrow f(ij)-f(i)\)</span> 即可，记 <span class="math inline">\(M=\min\{m_1,m_2,...,m_n\}\)</span>，复杂度为 <span class="math inline">\(O(\frac{M}{1}+\frac{M}{2}+...+\frac{M}{M})=O(M\log M)\)</span>。</p>
<p>这样对于每组数据的复杂度为 <span class="math inline">\(O(M\log M+Mn)\)</span>，可以通过部分测试点，但不能AC。如何优化？</p>
<p>去年的时候 immortalCO 讲过一种技巧：<span class="math inline">\(\lfloor\frac{M}{i}\rfloor\)</span> 只有不超过 <span class="math inline">\(2\sqrt M\)</span> 种取值，所以可以枚举 <span class="math inline">\(\lfloor\frac{M}{i}\rfloor\)</span> 的每种取值对应的 <span class="math inline">\(i\)</span> 的区间，每个区间可以快速计算。于是当时我就仔细研究了下 <span class="math inline">\(n=2\)</span> 的情形：由于 <span class="math inline">\(\lfloor\frac{m_1}{i}\rfloor\)</span> 和 <span class="math inline">\(\lfloor\frac{m_2}{i}\rfloor\)</span> 的段数之和不超过 <span class="math inline">\(2\sqrt{m_1}+2\sqrt{m_2}\)</span>，设某一段区间 <span class="math inline">\(i\in[l,r]\)</span> 的 <span class="math inline">\(\lfloor\frac{m_1}{i}\rfloor=a,\lfloor\frac{m_2}{i}\rfloor=b\)</span>，则这一段的和为</p>
<p><span class="math display">\[\sum_{i=l}^rf(i)\left[m_1a-\frac{1}{2}a(a+1)i\right]\left[m_2b-\frac{1}{2}b(b+1)i\right]
\\ =\sum_{i=l}^r\left[m_1m_2abf(i)-\frac{1}{2}a(a+1)m_2bif(i)-\frac{1}{2}b(b+1)m_1aif(i)+\frac{1}{4}a(a+1)b(b+1)i^2f(i)\right]\]</span></p>
<p>因此维护 <span class="math inline">\(f(i)\)</span> 的前缀和、<span class="math inline">\(if(i)\)</span> 的前缀和、<span class="math inline">\(i^2f(i)\)</span> 的前缀和，就能在预处理之后 <span class="math inline">\(O(\sqrt{M}n)\)</span> 解决每组数据，预处理时对每一个 <span class="math inline">\(c\)</span> 预处理 <span class="math inline">\(f(i),if(i),i^2f(i)\)</span> 的前缀和，可以通过 <span class="math inline">\(n=2\)</span> 的数据。</p>
<p>然后，由于我太辣鸡了并没有想出 <span class="math inline">\(n &gt; 2\)</span> 时怎么做……</p>
<p>等我后来看这道题的题解的时候，发现自己很蠢，明明想法已经十分接近正解，却没有继续想下去。其实这个性质进一步推广就是：对于所有的正整数 <span class="math inline">\(j\le n\)</span>，<span class="math inline">\(\lfloor\frac{m_j}{i}\rfloor\)</span> 的<strong>段数之和</strong>不超过 <span class="math inline">\(n\sqrt M\)</span>，而 <span class="math inline">\(n\le 11\)</span>，所以这个值显然是可以接受的。</p>
<p>对于每一段 <span class="math inline">\(i\in[l,r]\)</span>，记 <span class="math inline">\(\lfloor\frac{m_j}{i}\rfloor=a_j\)</span>，则 <span class="math inline">\(\prod_{j=1}^n\left[m_ja_j-\frac{1}{2}a_j(a_j+1)i\right]\)</span> 是一个 <span class="math inline">\(n\)</span> 次多项式 <span class="math inline">\(k_0+k_1i+k_2i^2+...+k_ni^n\)</span>，可以用 <span class="math inline">\(O(n^2)\)</span> 的时间暴力乘法，只要对每个 <span class="math inline">\(j=0,1,...,n\)</span> 维护了 <span class="math inline">\(i^jf(i)\)</span> 的前缀和，就能对于每一段 <span class="math inline">\([l,r]\)</span>，在 <span class="math inline">\(O(n^2)\)</span> 的时间内求出 <span class="math inline">\(\sum_{i=l}^r\prod_{j=1}^n\left[m_ja_j-\frac{1}{2}a_j(a_j+1)i\right]\)</span>。</p>
<p>预处理对每一个 <span class="math inline">\(c,j\)</span> 预处理 <span class="math inline">\(i^jf(i)\)</span> 的前缀和，因此总复杂度为 <span class="math inline">\(O(cnM+Tn^3\sqrt M)\)</span>。注意模意义下的运算比较多，注意乘法溢出，我一开始写的时候就因为乘法溢出WA成了50分，样例和 <span class="math inline">\(n\)</span> 较大的测试点都通过了，而 <span class="math inline">\(n\)</span> 较小的测试点反而错了，建议构造易于手算的 <span class="math inline">\(m_i\)</span> 比较大的测试数据，以及将代码中的 <code>int</code> 改成 <code>long long</code> 对拍。代码如下（由于LYDSY评测较慢且计算总时限，预处理满的 <span class="math inline">\(19\times 12\times 100000\)</span> 如果常数大会导致过不了，于是我先读入所有数据，得到最大的 <span class="math inline">\(n,c,m_i\)</span> 再预处理以缩短小测试点的运行时间）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 10007</span></span><br><span class="line"><span class="keyword">int</span> T,N[<span class="number">1000</span>],C[<span class="number">1000</span>],M[<span class="number">1000</span>][<span class="number">11</span>],maxn,maxc,maxm,</span><br><span class="line">	f[<span class="number">19</span>][<span class="number">100001</span>][<span class="number">12</span>],pos[<span class="number">7100</span>],a[<span class="number">12</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;T;t++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,N+t,C+t);</span><br><span class="line">		<span class="keyword">if</span>(N[t]&gt;maxn)maxn=N[t];</span><br><span class="line">		<span class="keyword">if</span>((C[t]-=<span class="number">2</span>)&gt;maxc)maxc=C[t];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N[t];i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,M[t]+i),M[t][i]&gt;maxm?maxm=M[t][i]:<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxc;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=*f[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;j&lt;=maxm;j++)*f[i][j]=i?(*f[i][j<span class="number">-1</span>]+*f[i<span class="number">-1</span>][j<span class="number">-1</span>])%MOD:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxc;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=maxm;j++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=j+j;k&lt;=maxm;k+=j)(*f[i][k]+=MOD-*f[i][j])%=MOD;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=maxn;k++)f[i][j][k]=f[i][j][k<span class="number">-1</span>]*j%MOD;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=maxn;k&gt;=<span class="number">0</span>;k--)(f[i][j][k]+=f[i][j<span class="number">-1</span>][k])%=MOD;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;T;t++)&#123;</span><br><span class="line">		<span class="keyword">int</span> n=N[t],c=C[t],*m=M[t],M=<span class="number">1</span>&lt;&lt;<span class="number">30</span>,cnt=<span class="number">0</span>,S=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)m[i]&lt;M?M=m[i]:<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>,t;j&lt;=M;j=m[i]/(m[i]/j)+<span class="number">1</span>)pos[cnt++]=j;</span><br><span class="line">		<span class="built_in">std</span>::sort(pos,pos+cnt);</span><br><span class="line">		cnt=<span class="built_in">std</span>::unique(pos,pos+cnt)-pos;</span><br><span class="line">		pos[cnt]=M+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">			*a=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>,A,B;j&lt;n;j++)&#123;</span><br><span class="line">				A=m[j]/pos[i]%MOD;B=-A*(A+<span class="number">1l</span>l)/<span class="number">2</span>%MOD;(A*=m[j])%=MOD;</span><br><span class="line">				a[j+<span class="number">1</span>]=a[j]*(B&lt;<span class="number">0</span>?B+=MOD:B)%MOD;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=j;k;k--)a[k]=(a[k]*A+a[k<span class="number">-1</span>]*B)%MOD;</span><br><span class="line">				(*a*=A)%=MOD;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)(S+=(f[c][pos[i+<span class="number">1</span>]<span class="number">-1</span>][j]-f[c][pos[i]<span class="number">-1</span>][j]+MOD)*a[j])%=MOD;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,S);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#top">返回顶部</a></p>
<hr>
<h3 id="codeforces-715c">7、Codeforces 715C</h3>
<p>给定无根树 <span class="math inline">\(T=(V,E)\)</span> 和正整数 <span class="math inline">\(M\)</span>，保证 <span class="math inline">\(\gcd(M,10)=1\)</span>，每条边 <span class="math inline">\(e_i=(u_i,v_i)\in E\)</span> 上有一个数 <span class="math inline">\(w_i\in\{1,2,...,9\}\)</span>，求 <span class="math inline">\(T\)</span> 中有多少条非空的有向路径 <span class="math inline">\((u,v)\)</span>，满足 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 的路径经过的数能被 <span class="math inline">\(M\)</span> 整除。一条依次经过边 <span class="math inline">\(e_1,e_2,...,e_{k-1}\)</span> 的路径经过的数定义为</p>
<p><span class="math display">\[\sum_{i=1}^{k-1}w_i\cdot 10^{k-i-1}\]</span></p>
<p>树 <span class="math inline">\(T\)</span> 的节点数 <span class="math inline">\(n\le 100,000\)</span>，<span class="math inline">\(M\le 10^9\)</span>。</p>
<p>http://codeforces.com/problemset/problem/715/C</p>
<p>这场CF也是我打挂的一场，我考场上没做出这题。</p>
<p>这是一道解法比较显然的题。</p>
<p>路径统计问题很容易想到树分治，即先找出树的重心 <span class="math inline">\(g\in V\)</span>，然后统计<strong>经过 <span class="math inline">\(g\)</span> 且满足条件</strong>的路径数，接着把 <span class="math inline">\(g\)</span> 删掉，将 <span class="math inline">\(T\)</span> 分成多个子树 <span class="math inline">\(T_1,T_2,...,T_k\)</span>，对每个子树 <span class="math inline">\(T_i(i=1,2,...,k)\)</span> 递归处理。</p>
<p>如果找出了树的重心 <span class="math inline">\(g\)</span>，怎么求有多少条路径经过点 <span class="math inline">\(g\)</span> 且路径经过的数在模 <span class="math inline">\(M\)</span> 意义下为 <span class="math inline">\(0\)</span>？这个也是很好处理的，对于路径 <span class="math inline">\((u,v)\)</span>，如果记 <span class="math inline">\(w_1,w_2,...,w_p\)</span> 为从 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(g\)</span> 的路径依次经过的数，<span class="math inline">\(g\)</span> 到 <span class="math inline">\(v\)</span> 的路径依次经过的数为 <span class="math inline">\(w_{p+1},...,w_{k-1}\)</span>，那么</p>
<p><span class="math display">\[\sum_{i=1}^{k-1}10^{k-i-1}w_i\equiv 0\pmod M\Leftrightarrow\sum_{i=1}^p10^{p-i}w_i\equiv-\sum_{i=p+1}^{k-1}10^{p-i}w_i\pmod M\]</span></p>
<p>注意上面的式子除以了 <span class="math inline">\(10\)</span> 的幂，需要利用 <span class="math inline">\(\gcd(M,10)\)</span> 的性质，求出 <span class="math inline">\(10\)</span> 在模 <span class="math inline">\(M\)</span> 意义下的逆元。以 <span class="math inline">\(u\rightarrow g\)</span> 的路径为例，<span class="math inline">\(p-i\)</span> 就是以 <span class="math inline">\(g\)</span> 为根时这条边的终点在 <span class="math inline">\(T\)</span> 中的深度。</p>
<p>以 <span class="math inline">\(g\)</span> 为根对 <span class="math inline">\(T\)</span> 遍历求出每个点的深度 <span class="math inline">\(d_i\)</span>（<span class="math inline">\(d_g=0,d_i=d_{f_i}+1\)</span>），然后对于一条边 <span class="math inline">\(e_i=(f_v,v)\)</span>，定义其权值</p>
<p><span class="math display">\[a_v=10^{d_{f_v}}w_i\bmod M\]</span></p>
<p><span class="math display">\[b_v=-10^{-d_v}w_i\]</span></p>
<p>求出每个点到 <span class="math inline">\(g\)</span> 的路径上的 <span class="math inline">\(a_v\)</span> 和 <span class="math inline">\(b_v\)</span> 边权的和 <span class="math inline">\(A_v,B_v\)</span>（<span class="math inline">\(A_g=B_g=0,A_v=A_{f_v}+a_v\bmod M,B_v=B_{f_v}+b_v\bmod M\)</span>），这样一条过点 <span class="math inline">\(g\)</span> 的路径 <span class="math inline">\((u,v)\)</span> 合法当且仅当 <span class="math inline">\(A_u=B_v\)</span>。</p>
<p>如何只统计过点 <span class="math inline">\(g\)</span> 的路径？以 <span class="math inline">\(g\)</span> 为根时，记 <span class="math inline">\(g\)</span> 有 <span class="math inline">\(c\)</span> 个子节点，把 <span class="math inline">\(g\)</span> 标记为 <span class="math inline">\(0\)</span>，把 <span class="math inline">\(g\)</span> 的每一个子树标记为 <span class="math inline">\(1,2,...,c\)</span>，记 <span class="math inline">\(t_i\)</span> 为节点 <span class="math inline">\(i\)</span> 标记的树，现在的任务是统计满足以下条件的点对 <span class="math inline">\(u,v\)</span> 数：</p>
<p><span class="math display">\[t_u\ne t_v,A_u=B_v\]</span></p>
<p>一种简单粗暴的做法是把 <span class="math inline">\(V\)</span> 中的点按双关键字 <span class="math inline">\((A_v,t_v)\)</span> 排序得到序列 <span class="math inline">\(A&#39;\)</span>，按双关键字 <span class="math inline">\((B_v,t_v)\)</span> 排序得到序列 <span class="math inline">\(B&#39;\)</span>，接着对 <span class="math inline">\(A&#39;\)</span> 中的每个元素 <span class="math inline">\(u\)</span> 在 <span class="math inline">\(B&#39;\)</span> 中用Two-Pointers技巧找出满足 <span class="math inline">\(A_u=B_v\)</span> 的 <span class="math inline">\(v\)</span> 的个数以及 <span class="math inline">\(A_u=B_v,t_u=t_v\)</span> 的 <span class="math inline">\(v\)</span> 的个数，相减就是满足 <span class="math inline">\(A_u=B_v,t_u\ne t_v\)</span> 的 <span class="math inline">\(v\)</span> 的个数。由于要排序，每层复杂度为 <span class="math inline">\(O(n\log n)\)</span>，总复杂度是 <span class="math inline">\(O(n\log^2n)\)</span>，可以通过本题。也可以使用Hash表进一步优化复杂度。</p>
<p>然而就这么一道裸题我在考场上都写不出来，可见我的代码能力有多差……代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fe for(edge*e=first[x];e;e=e-&gt;next)<span class="meta-keyword">if</span>(!vis[e-&gt;to]&amp;&amp;e-&gt;to!=fa[x])</span></span><br><span class="line"><span class="keyword">int</span> n,M;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> pow1[<span class="number">100010</span>],pow2[<span class="number">100010</span>],ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> to,w;edge*next;&#125;E[<span class="number">200010</span>],*ne=E,*first[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;*ne=(edge)&#123;v,w,first[u]&#125;;first[u]=ne++;&#125;</span><br><span class="line"><span class="keyword">int</span> Q[<span class="number">100010</span>],fa[<span class="number">100010</span>],siz[<span class="number">100010</span>],fr[<span class="number">100010</span>],dep[<span class="number">100010</span>],D1[<span class="number">100010</span>],D2[<span class="number">100010</span>],L[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> a==<span class="number">1</span>?<span class="number">1</span>:(<span class="number">1</span>+p*(a-inv(p%a,a)))/a%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;<span class="keyword">return</span> D1[i]&lt;D1[j]||D1[i]==D1[j]&amp;&amp;fr[i]&lt;fr[j];&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;<span class="keyword">return</span> D2[i]&lt;D2[j]||D2[i]==D2[j]&amp;&amp;fr[i]&lt;fr[j];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> head=<span class="number">0</span>,tail=<span class="number">1</span>,x=Q[<span class="number">0</span>]=root,g=<span class="number">0</span>;fa[x]=<span class="number">-1</span>;siz[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;head&lt;tail;x=Q[++head])</span><br><span class="line">		Fe fa[Q[tail++]=e-&gt;to]=x,siz[e-&gt;to]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(head--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(fa[x=Q[head]]!=<span class="number">-1</span>)siz[fa[x]]+=siz[x];</span><br><span class="line">		<span class="keyword">bool</span> isg=tail-siz[x]&lt;=tail/<span class="number">2</span>;</span><br><span class="line">		<span class="function">Fe <span class="title">if</span><span class="params">(siz[e-&gt;to]&gt;tail/<span class="number">2</span>)</span>isg</span>=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(isg)&#123;g=x;<span class="keyword">break</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	vis[g]=<span class="number">1</span>;</span><br><span class="line">	head=<span class="number">0</span>,tail=<span class="number">1</span>,Q[<span class="number">0</span>]=L[<span class="number">0</span>]=x=g,fa[x]=<span class="number">-1</span>,dep[x]=fr[x]=D1[x]=D2[x]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ccnt=<span class="number">0</span>,len=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;head&lt;tail;x=Q[++head],L[head]=x)Fe&#123;</span><br><span class="line">		fa[Q[tail++]=e-&gt;to]=x;fr[e-&gt;to]=x==g?++ccnt:fr[x];dep[e-&gt;to]=dep[x]+<span class="number">1</span>;</span><br><span class="line">		D1[e-&gt;to]=(D1[x]+pow1[dep[x]]*e-&gt;w)%M;</span><br><span class="line">		D2[e-&gt;to]=(D2[x]+pow2[dep[e-&gt;to]]*e-&gt;w)%M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::sort(Q,Q+tail,cmp2);</span><br><span class="line">	<span class="built_in">std</span>::sort(L,L+tail,cmp1);</span><br><span class="line">	<span class="keyword">int</span> l0=<span class="number">0</span>,r0=<span class="number">0</span>,l1=<span class="number">0</span>,r1=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tail;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(l0&lt;tail&amp;&amp;D2[Q[l0]]&lt;D1[L[i]])l0++;</span><br><span class="line">		<span class="keyword">while</span>(r0&lt;tail&amp;&amp;D2[Q[r0]]&lt;=D1[L[i]])r0++;</span><br><span class="line">		<span class="keyword">while</span>(l1&lt;tail&amp;&amp;(D2[Q[l1]]&lt;D1[L[i]]||D2[Q[l1]]==D1[L[i]]&amp;&amp;fr[Q[l1]]&lt;fr[L[i]]))l1++;</span><br><span class="line">		<span class="keyword">while</span>(r1&lt;tail&amp;&amp;(D2[Q[r1]]&lt;D1[L[i]]||D2[Q[r1]]==D1[L[i]]&amp;&amp;fr[Q[r1]]&lt;=fr[L[i]]))r1++;</span><br><span class="line">		ans+=r0-l0-r1+l1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(edge*e=first[g];e;e=e-&gt;next)</span><br><span class="line">		<span class="keyword">if</span>(!vis[e-&gt;to])solve(e-&gt;to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;M);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,w;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">		link(u,v,w);link(v,u,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> I=inv(<span class="number">10</span>,M);</span><br><span class="line">	*pow1=<span class="number">1</span>%M;*pow2=(M<span class="number">-1</span>)%M;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=*pow1=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		pow1[i]=pow1[i<span class="number">-1</span>]*<span class="number">10</span>%M;</span><br><span class="line">		pow2[i]=pow2[i<span class="number">-1</span>]*I%M;</span><br><span class="line">	&#125;</span><br><span class="line">	solve(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#top">返回顶部</a></p>
<hr>
<h3 id="lydsy-3451">8、LYDSY 3451</h3>
<p>给定无根树 <span class="math inline">\(T\)</span>，记 <span class="math inline">\(T\)</span> 的节点数 <span class="math inline">\(n=|V(T)|\)</span>，初始时 <span class="math inline">\(S=0\)</span>，然后进行如下的分治过程：</p>
<ul>
<li><span class="math inline">\(S\leftarrow S+|T|\)</span></li>
<li>若 <span class="math inline">\(|T|=1\)</span>，结束</li>
<li>等概率随机选取 <span class="math inline">\(T\)</span> 的一个节点 <span class="math inline">\(v\in V(T)\)</span>，从 <span class="math inline">\(T\)</span> 中删去 <span class="math inline">\(v\)</span> 及与 <span class="math inline">\(v\)</span> 关联的边，把 <span class="math inline">\(T\)</span> 分成若干个更小的树 <span class="math inline">\(T_1,T_2,...,T_k\)</span></li>
<li>对每个 <span class="math inline">\(T_i(i=1,2,...,k)\)</span> 递归处理该过程</li>
</ul>
<p>求分治过程结束之后，<span class="math inline">\(S\)</span> 的值的期望值 <span class="math inline">\(E(S)\)</span>。<span class="math inline">\(n\le 30,000\)</span>。</p>
<p>http://www.lydsy.com/JudgeOnline/problem.php?id=3451</p>
<p>首先说一下，这题的解法是树分治。</p>
<p><strong>用树分治求树分治的期望复杂度？</strong></p>
<p>这是一道很神的题。</p>
<p>首先，联想一下普通的点分治为什么每层分治的复杂度是 <span class="math inline">\(O(|T|)\)</span> 的，因为通常需要遍历一遍整个树 <span class="math inline">\(T\)</span>。所以我们可以修改一下分治过程：对每个点 <span class="math inline">\(v\)</span> 记录 <span class="math inline">\(v\)</span> 被经过的次数 <span class="math inline">\(S(v)\)</span>，然后把 <span class="math inline">\(S\leftarrow S+|T|\)</span> 这一步改成对于每个 <span class="math inline">\(v\in V(T)\)</span>，修改 <span class="math inline">\(S(v)\leftarrow S(v)+1\)</span>（一个点被删去后 <span class="math inline">\(S(v)\)</span> 的值就确定下来了）。那么 <span class="math inline">\(S=\sum_{v\in V(T)}S(v)\)</span>，因此</p>
<p><span class="math display">\[E(S)=E(\sum_{v\in V(T)}S(v))=\sum_{v\in V(T)}E(S(v))\]</span></p>
<p>因此只需对每个点 <span class="math inline">\(v\)</span> 考虑 <span class="math inline">\(E(S(v))\)</span>。问题已经简单了一些，不过 <span class="math inline">\(E(S(v))\)</span> 该怎么求？</p>
<p>继续分析。考虑 <span class="math inline">\(v\)</span> 在递归过程中递归了几层（以下记 <span class="math inline">\(u\)</span> 为这一层递归选取删除的点）：</p>
<p>（1）如果 <span class="math inline">\(u=v\)</span>，那么 <span class="math inline">\(v\)</span> 被删去，结束；</p>
<p>（2）如果 <span class="math inline">\(u\ne v\)</span>，将 <span class="math inline">\(T\)</span> 以 <span class="math inline">\(v\)</span> 为根转成有根树，删去 <span class="math inline">\(u\)</span> 为根的子树即可（剩下部分就是删去 <span class="math inline">\(u\)</span> 后 <span class="math inline">\(v\)</span> 所在的连通块，删除部分不再考虑），递归处理。</p>
<p>因此 <span class="math inline">\(S(v)\)</span> 的值其实是这样的：以 <span class="math inline">\(v\)</span> 为根，一开始 <span class="math inline">\(S(v)=0\)</span>，然后重复以下过程：</p>
<ul>
<li>令 <span class="math inline">\(S(v)\leftarrow S(v)+1\)</span></li>
<li>等概率随机选取 <span class="math inline">\(u\in V(T)\)</span>，从 <span class="math inline">\(T\)</span> 中删去以 <span class="math inline">\(u\)</span> 为根的子树</li>
<li>如果 <span class="math inline">\(T\)</span> 为空，结束</li>
</ul>
<p><span class="math inline">\(S(v)\)</span> 就是这个过程的期望步数，但我们还是不知道它是多少。</p>
<p>这里我的处理方法是这样的：记 <span class="math inline">\(U\)</span> 为该过程中所有被第2步选为 <span class="math inline">\(u\)</span> 的节点集合，那么 <span class="math inline">\(S(v)=|U|\)</span>，因此</p>
<p><span class="math display">\[E(S(v))=E(|U|)=E(\sum_{u\in V(T)}[u\in U])=\sum_{u\in V(T)}P(u\in U)\]</span></p>
<p>问题更加简单了，只需求每个点出现在 <span class="math inline">\(U\)</span> 中的概率。设以 <span class="math inline">\(v\)</span> 为根时 <span class="math inline">\(u\)</span> 的祖先个数为 <span class="math inline">\(d_{v,u}\)</span>（<strong>假设一个点的祖先包含其本身，因此就是 <span class="math inline">\(u,v\)</span> 路径上的节点数</strong>），在删的过程中，每一步删除的点或者不是 <span class="math inline">\(u\)</span> 的祖先，这时候** <span class="math inline">\(u\)</span> 的祖先集合不变**，或者删的点是 <span class="math inline">\(u\)</span> 的祖先，因选取是等概率的，有 <span class="math inline">\(\frac{1}{d_{v,u}}\)</span> 的概率删去 <span class="math inline">\(u\)</span>，此时必有 <span class="math inline">\(u\in U\)</span>，还有 <span class="math inline">\(1-\frac{1}{d_{v,u}}\)</span> 的概率删去除 <span class="math inline">\(u\)</span> 外 <span class="math inline">\(u\)</span> 的祖先，此时 <span class="math inline">\(u\)</span> 作为子树内节点被删除，必有 <span class="math inline">\(u\not\in U\)</span>。由于最终至少有一个 <span class="math inline">\(u\)</span> 的祖先被删去（起码根 <span class="math inline">\(v\)</span> 会被删去），而 <span class="math inline">\(u\)</span> 的任何一个祖先被删除 <span class="math inline">\([u\in U]\)</span> 就确定了，所以 <span class="math inline">\(P(u\in U)=\frac{1}{d_{v,u}}\)</span>。</p>
<p>这样结论就出来了：</p>
<p><span class="math display">\[E(S)=\sum_{v\in V(T)}E(S(v))=\sum_{v\in V(T)}\sum_{u\in V(T)}P(u\in U)=\sum_{v\in V(T)}\sum_{u\in V(T)}\frac{1}{d_{v,u}}\]</span></p>
<p>你可能会说，到这里我们都只是在用树分治的性质啊，并没有真正写树分治啊！慢着——你有没发现直接用上面的式子计算起码是 <span class="math inline">\(O(n^2)\)</span> 的？怎么优化？</p>
<p>这个问题是“求树的所有路径的经过节点数的倒数和”，其实是一个树路径统计问题，有一种经典的做法——树分治。</p>
<p>由于我们只要对每个 <span class="math inline">\(l=0,1,...,n-1\)</span> 求出距离为 <span class="math inline">\(l\)</span> 的有对数 <span class="math inline">\(\mathrm{cnt}_l\)</span> 就能得到答案 <span class="math inline">\(\sum_{l=0}^l\frac{\mathrm{cnt}_l}{l+1}\)</span>，所以接着讨论如何计算所有 <span class="math inline">\(\mathrm{cnt}_l\)</span>。考虑点分治，找出树的重心 <span class="math inline">\(g\)</span> 后，把有向路径分成两类：不过点 <span class="math inline">\(g\)</span> 的路径、过点 <span class="math inline">\(g\)</span> 的路径。对于前者可以递归处理，因此只讨论后者。先预处理出 <span class="math inline">\(f_T(i)\)</span> 为树 <span class="math inline">\(T\)</span> 中距离 <span class="math inline">\(g\)</span> 为 <span class="math inline">\(i\)</span>（<strong>这里的距离定义为经过的边数</strong>）的节点数，<span class="math inline">\(f_{T_c}(i)\)</span> 为 <span class="math inline">\(T\)</span> 的子树 <span class="math inline">\(c\)</span>（删去 <span class="math inline">\(g\)</span> 之后，一个连通块就是一个子树）中和 <span class="math inline">\(T\)</span> 重心 <span class="math inline">\(g\)</span> 距离为 <span class="math inline">\(i\)</span> 的节点数，则过点 <span class="math inline">\(g\)</span> 且长度为 <span class="math inline">\(l\)</span> 的有向路径数为（证明略）：</p>
<p><span class="math display">\[\sum_{a=0}^lf_T(a)f_T(l-a)-\sum_{c}\sum_{a=0}^lf_{T_c}(a)f_{T_c}(l-a)\]</span></p>
<p>注意到对每个 <span class="math inline">\(l\)</span> 计算 <span class="math inline">\(\sum_{a=0}^lf_T(a)f_T(l-a)\)</span> 是一个卷积的形式，可以用 FFT 优化到 <span class="math inline">\(O(|T|\log |T|)\)</span>。这样就能在总共 <span class="math inline">\(O(n\log^2 n)\)</span> 的时间内对每个 <span class="math inline">\(l\)</span> 求出全树中长度为 <span class="math inline">\(l\)</span> 的有向路径数。<strong>这个做法比较慢，如果有更优秀的解法欢迎讨论。</strong>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fe(x) for(edge*e=first[x];e;e=e-&gt;next)<span class="meta-keyword">if</span>(!vis[e-&gt;to]&amp;&amp;e-&gt;to!=fa[x])</span></span><br><span class="line">ll w[<span class="number">1</span>&lt;&lt;<span class="number">16</span>];</span><br><span class="line"><span class="function">ll <span class="title">pow</span><span class="params">(ll a,<span class="keyword">int</span> n=MOD<span class="number">-2</span>)</span></span>&#123;ll b=<span class="number">1</span>;<span class="keyword">for</span>(;n;n&gt;&gt;=<span class="number">1</span>)n%<span class="number">2</span>?b=b*a%MOD:<span class="number">1</span>,a=a*a%MOD;<span class="keyword">return</span> b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFT</span><span class="params">(<span class="keyword">int</span>*a,<span class="keyword">int</span> n,<span class="keyword">bool</span> ty=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    w[*w=<span class="number">1</span>]=<span class="built_in">pow</span>(<span class="number">3</span>,(MOD<span class="number">-1</span>)/n);</span><br><span class="line">    <span class="keyword">if</span>(ty)w[<span class="number">1</span>]=<span class="built_in">pow</span>(w[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)w[i]=w[i<span class="number">-1</span>]*w[<span class="number">1</span>]%MOD;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,t;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)t=a[i],a[i]=a[j],a[j]=t;</span><br><span class="line">        <span class="keyword">for</span>(t=n&gt;&gt;<span class="number">1</span>;(j^=t)&lt;t;t&gt;&gt;=<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,m=<span class="number">1</span>;m&lt;n;i++,m&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j+=<span class="number">1</span>&lt;&lt;i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>,t;k&lt;m;k++)&#123;</span><br><span class="line">        t=a[j+m+k]*w[(n&gt;&gt;i)*k]%MOD;</span><br><span class="line">        a[j+m+k]=(a[j+k]+MOD-t)%MOD;</span><br><span class="line">        a[j+k]=(a[j+k]+t)%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ty)&#123;</span><br><span class="line">        ll I=<span class="built_in">pow</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)a[i]=a[i]*I%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> to;edge*next;&#125;E[<span class="number">60010</span>],*ne=E,*first[<span class="number">30010</span>];</span><br><span class="line"><span class="keyword">int</span> Q[<span class="number">30010</span>],fa[<span class="number">30010</span>],s[<span class="number">30010</span>],A[<span class="number">30010</span>],ans[<span class="number">1</span>&lt;&lt;<span class="number">16</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">30010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;*ne=(edge)&#123;b,first[a]&#125;;first[a]=ne++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span>*h,<span class="keyword">int</span>*t,<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N=<span class="number">1</span>;<span class="keyword">while</span>(N&lt;=n&lt;&lt;<span class="number">1</span>)N&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(A,<span class="number">0</span>,N&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>*i=h;i&lt;t;i++)A[s[*i]]++;</span><br><span class="line">    DFT(A,N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)A[i]=<span class="number">1l</span>l*A[i]*A[i]%MOD;</span><br><span class="line">    DFT(A,N,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)ans[i]+=k*A[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> g)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>*h=Q,*t=Q+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(g=fa[*h=g]=<span class="number">-1</span>;h&lt;t;s[*(h++)]=<span class="number">1</span>)</span><br><span class="line">        Fe(*h)fa[*(t++)=e-&gt;to]=*h;</span><br><span class="line">    <span class="keyword">while</span>(g&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">bool</span> f=t-Q-s[*(--h)]&lt;=t-Q&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        Fe(*h)s[e-&gt;to]&gt;t-Q&gt;&gt;<span class="number">1</span>?f=<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">        f?g=*h:<span class="number">1</span>;</span><br><span class="line">        fa[*h]&gt;<span class="number">-1</span>?s[fa[*h]]+=s[*h]:<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[*Q=g]=<span class="number">1</span>;fa[g]=<span class="number">-1</span>;s[g]=<span class="number">0</span>;h=t=Q+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>,m,*q;</span><br><span class="line">    Fe(g)&#123;</span><br><span class="line">        <span class="keyword">for</span>(s[*(q=t++)=e-&gt;to]=<span class="number">1</span>,fa[e-&gt;to]=g;h&lt;t;h++)</span><br><span class="line">            Fe(*h)fa[*(t++)=e-&gt;to]=*h,s[e-&gt;to]=s[*h]+<span class="number">1</span>;</span><br><span class="line">        calc(q,t,(m=s[t[<span class="number">-1</span>]])&gt;n?n=m:m,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    calc(Q,t,n,<span class="number">1</span>);</span><br><span class="line">    Fe(g)solve(e-&gt;to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b),link(a,b),link(b,a);</span><br><span class="line">    solve(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)s+=ans[i]/(i+<span class="number">1.0L</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.4lf"</span>,(<span class="keyword">double</span>)s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#top">返回顶部</a></p>
<hr>
<h3 id="uoj-59">9、UOJ #59</h3>
<p>给定一个 <span class="math inline">\(n\)</span> 元一次同余方程组</p>
<p><span class="math display">\[\begin{cases} a_{0,0}x_0+a_{0,1}x_1+...+a_{0,n-1}x_{n-1}\equiv c_0\pmod b_0 \\ a_{1,0}x_0+a_{1,1}x_1+...+a_{1,n-1}x_{n-1}\equiv c_1\pmod b_1 \\ ... \\ a_{m-1,0}x_0+a_{m-1,1}x_1+...+a_{m-1,n-1}x_{n-1}\equiv c_{m-1}\pmod b_{m-1}\end{cases}\]</span></p>
<p>求一组解 <span class="math inline">\((x_1,x_2,...,x_n)\)</span> 满足尽量多的方程。<strong>提交答案题</strong>，详细数据及评分方式见链接。</p>
<p>http://uoj.ac/problem/59</p>
<p>WC滚粗前最后刷的一道题。</p>
<p>既然是提交答案题，我们就需要先观察各个测试点的特征。</p>
<h4 id="测试点1">测试点1</h4>
<p>该测试点满足 <span class="math inline">\(n=1,m=5000\)</span>，所有 <span class="math inline">\(b_i=1058400\)</span>。</p>
<p>做法很简单，由于只有一个变量 <span class="math inline">\(x_1\)</span>，不妨记为 <span class="math inline">\(x\)</span>，注意到如果 <span class="math inline">\(a_ix\equiv c_i\pmod b_i\)</span>，那么 <span class="math inline">\(a_i(x\bmod b_i)\equiv c_i\pmod b_i\)</span>，因此只需在 <span class="math inline">\(\{0,1,...,1058400-1\}\)</span> 中枚举 <span class="math inline">\(x\)</span>，然后判断一下能满足多少个方程。</p>
<p>这样时间效率为 <span class="math inline">\(1058400\times 5000\)</span>，可以跑出测试点1。事实上可以直接解每一个同余方程进一步优化时间效率。</p>
<h4 id="测试点2">测试点2</h4>
<p>该测试点满足 <span class="math inline">\(n=1,m=50\)</span>，所有 <span class="math inline">\(b_i\)</span> 为不超过 <span class="math inline">\(2^31\)</span> 的正整数。</p>
<p>这时候最优的 <span class="math inline">\(x\)</span> 可能很大，不能再直接枚举。</p>
<p>通过写程序验证，我们发现有 <span class="math inline">\(13\)</span> 个方程的 <span class="math inline">\(\gcd(a_i,b_i)\not|c_i\)</span>，不可能被满足，因此把这些方程删掉。对于剩下的方程，可以将 <span class="math inline">\(a_i,b_i,c_i\)</span> 同时除以 <span class="math inline">\(\gcd(a_i,b_i)\)</span>，然后将 <span class="math inline">\(c_i\)</span> 乘上 <span class="math inline">\(a_i\)</span> 在模 <span class="math inline">\(b_i\)</span> 意义下的逆元，在令 <span class="math inline">\(a_i=1\)</span>，就能把方程化为 <span class="math inline">\(x\equiv c_i\pmod b_i\)</span> 的形式。</p>
<p>进一步通过程序验证发现，删掉这些方程之后，剩下的 <span class="math inline">\(b_i\)</span> 两两互质，因此一定存在一组 <span class="math inline">\(x_i\)</span> 同时满足这 <span class="math inline">\(37\)</span> 个方程。</p>
<p>可以使用中国剩余定理构造满足所有同余方程 <span class="math inline">\(x\equiv c_i\pmod b_i(0\le i &lt; m)\)</span> 的一个合法解：记 <span class="math inline">\(P_i=\prod_{0\le j &lt; m,j\ne i}b_j\)</span>，即除 <span class="math inline">\(b_i\)</span> 外所有 <span class="math inline">\(b_j\)</span> 的乘积；构造 <span class="math inline">\(m\)</span> 个数 <span class="math inline">\(x_0,x_1,...,x_{m-1}\)</span>，其中 <span class="math inline">\(x_i=P_i\cdot(P_i^{-1}\bmod b_i)\cdot c_i\)</span>，这里 <span class="math inline">\(a^{-1}\bmod b\)</span> 表示 <span class="math inline">\(a\)</span> 在模 <span class="math inline">\(b\)</span> 下的逆元，那么</p>
<p><span class="math display">\[\begin{cases}x_i\equiv 0\pmod b_j,&amp;i\ne j\\x_i\equiv c_j\pmod b_j,&amp;i=j\end{cases}\]</span></p>
<p>因此 <span class="math inline">\(x=\sum_{i=0}^{m-1}x_i\)</span> 就是一个合法解。由于 <span class="math inline">\(x\)</span> 可能很大，超过 <code>int</code> 甚至 <code>long long</code> 范围，需要使用高精度。</p>
<h4 id="测试点3">测试点3</h4>
<p>该测试点满足 <span class="math inline">\(n=m=300\)</span>，所有 <span class="math inline">\(b_i=1000000007\)</span>。</p>
<p>不难发现，这就相当于在模 <span class="math inline">\(1000000007\)</span> 意义下解 <span class="math inline">\(n\)</span> 元一次线性方程组，因为 <span class="math inline">\(1000000007\)</span> 是质数，所以所有模意义下非 <span class="math inline">\(0\)</span> 数都有逆元，因此可以直接高斯消元解决。</p>
<p>实测证明，该方程组在模 <span class="math inline">\(1000000007\)</span> 意义下有唯一解。这样就在 <span class="math inline">\(300^3\)</span> 的时间内高效地解决了该测试点。</p>
<h4 id="测试点4">测试点4</h4>
<p>该测试点满足 <span class="math inline">\(n=20,m=845\)</span>，所有 <span class="math inline">\(b_i=1000000007\)</span>。</p>
<p>通过观察测试点，还能发现，前 <span class="math inline">\(800\)</span> 个方程以每 <span class="math inline">\(40\)</span> 个为一组，每组内的方程系数 <span class="math inline">\(a_{i,j}\)</span> 完全相同，常数项 <span class="math inline">\(c_i\)</span> 只有两种取值，每种出现 <span class="math inline">\(20\)</span> 次，并且这 <span class="math inline">\(20\)</span> 个组的方程的系数构成一个上三角矩阵；除了这 <span class="math inline">\(20\)</span> 组方程以外还有 <span class="math inline">\(45\)</span> 个方程。</p>
<p>容易发现，每组方程或者满足一半（<span class="math inline">\(20\)</span> 个）或者都不满足（<span class="math inline">\(0\)</span> 个），如果都满足一半，就能满足 <span class="math inline">\(400\)</span> 个方程；如果有 <span class="math inline">\(3\)</span> 组没有满足，那么最多满足 <span class="math inline">\(340+45 &lt; 400\)</span> 个方程，因此最多有 <span class="math inline">\(2\)</span> 组不被满足，剩下的只要 <span class="math inline">\(2^{20}\)</span> 枚举每组方程满足哪一半即可，时间效率约为 <span class="math inline">\(C_20^2\times 2^{18}\times 20\times 845\)</span>，需要很长时间才能得到答案。</p>
<p>事实上最优解满足每组方程都满足一半（因此下面的代码是面向数据的），本人并不知道是否有更好的方法判断这个条件成立。如果只枚举这种情况，那么时间效率约为 <span class="math inline">\(2^{20}\times 20\times 845\)</span>。</p>
<h4 id="测试点5">测试点5</h4>
<p>该测试点满足 <span class="math inline">\(n=m=100\)</span>，所有 <span class="math inline">\(b_i=223092870\)</span>。</p>
<p>看起来和测试点3差不多，但实际上是有区别的，<span class="math inline">\(b_i\)</span> 不是质数，所以消元时可能出现没有逆元而消不掉的情况。</p>
<p>去年在做这个点的时候不会处理，直接消元结果挂了，于是通过一些随机打乱调整消元顺序的方法强行消出解，过掉了，然而这个做法不靠谱就是了。</p>
<p>靠谱的做法是这样的：因为</p>
<p><span class="math display">\[223092870=2\times 3\times 5\times 7\times 11\times 13\times 17\times 19\times 23\]</span></p>
<p>所以由 <span class="math inline">\(x\bmod 223092870=c\)</span> 可以得到 <span class="math inline">\(x\bmod 2=c\bmod 2\)</span>，<span class="math inline">\(x\bmod 3=c\bmod 3\)</span>，…，<span class="math inline">\(x\bmod 23=c\bmod 23\)</span>。同时利用中国剩余定理，由这 <span class="math inline">\(9\)</span> 个方程可以合并得到 <span class="math inline">\(x\bmod 223092870=c\)</span>，也就是说把每个方程拆成模数为 <span class="math inline">\(p_0=2,p_1=3,p_2=5,...,p_8=23\)</span> 的 <span class="math inline">\(9\)</span> 个方程以后，方程组是等价的。</p>
<p>因此，把 <span class="math inline">\(m\)</span> 个方程拆成 <span class="math inline">\(9m\)</span> 个方程以后，枚举 <span class="math inline">\(i=0,1,...,8\)</span>，取出所有模数是 <span class="math inline">\(p_i\)</span> 的方程，然后调用测试点3的程序求出一组解 <span class="math inline">\(x_{i,0},x_{i,1},...,x_{i,n-1}\)</span>。最后对于每个 <span class="math inline">\(j=0,1,...,n-1\)</span>，用测试点2用到的中国剩余定理合并所有的 <span class="math inline">\(x_{i,j}(0\le i &lt; 9)\)</span> 得到 <span class="math inline">\(x_j\)</span>。因为模数在 <code>int</code> 范围内，所以可以直接在模 <span class="math inline">\(223092870\)</span> 下计算，不需要高精度。</p>
<p>写个程序就能发现对于每个 <span class="math inline">\(i\)</span>，都存在一组满足所有方程的解，因此合并之后的 <span class="math inline">\(x_0,x_1,...,x_{n-1}\)</span> 也能满足所有方程。这样的运行效率约为 <span class="math inline">\(100^3\times 9\)</span>。</p>
<h4 id="测试点6">测试点6</h4>
<p>该测试点满足 <span class="math inline">\(n=m=50\)</span>，所有的 <span class="math inline">\(b_i\)</span> 为不超过 <span class="math inline">\(2^31\)</span> 的正整数。</p>
<p>有了之前的经验，把模数 <span class="math inline">\(b_i\)</span> 质因数分解，可以发现所有的 <span class="math inline">\(b_i\)</span> 分解之后都是若干个不超过 <span class="math inline">\(200\)</span> 的质数的乘积。</p>
<p>同样地，对于一个方程 <span class="math inline">\(i\)</span>，分解 <span class="math inline">\(b_i=p_0p_1...p_{k-1}\)</span>，其中 <span class="math inline">\(p_j(j=0,1,...,k-1)\)</span> 是质数，那么就可以对每个 <span class="math inline">\(j=0,1,...,k-1\)</span>，把方程 <span class="math inline">\(i\)</span> 模 <span class="math inline">\(p_j\)</span>（即所有系数 <span class="math inline">\(a_{i,j}\)</span> 和常数项 <span class="math inline">\(c_i\)</span> 同时模 <span class="math inline">\(p_j\)</span>，模数为 <span class="math inline">\(p_j\)</span>）得到 <span class="math inline">\(k\)</span> 个方程，显然拆完之后是等价的。</p>
<p>接着做法和测试点5是差不多的：对于每个 <span class="math inline">\(200\)</span> 以内的质数 <span class="math inline">\(p\)</span>，把所有模数为 <span class="math inline">\(p\)</span> 的方程取出来求出模 <span class="math inline">\(p\)</span> 意义下的一组解，和测试点5一样，数据满足所有方程都能被满足，最后用中国剩余定理合并。</p>
<p>值得注意的是这里需要高精度，因为 <span class="math inline">\(200\)</span> 以内的质数乘积很大。</p>
<h4 id="测试点7">测试点7</h4>
<p>该测试点满足 <span class="math inline">\(n=50,m=200\)</span>，所有 <span class="math inline">\(b_i=176400\)</span>。</p>
<p>同时观察发现这个测试点和测试点4很像——有大量重复的方程出现。这里，前 <span class="math inline">\(50\)</span> 个方程是完全相同的，后 <span class="math inline">\(150\)</span> 个方程中，对于每个 <span class="math inline">\(j=0,1,...,n-1\)</span> 有一组 <span class="math inline">\(3\)</span> 个方程 <span class="math inline">\(i\)</span> 满足 <span class="math inline">\(a_{i,j}=1,\forall k\ne j,a_{i,k}=0\)</span>，并且这一组 <span class="math inline">\(3\)</span> 个方程的 <span class="math inline">\(c_i\)</span> 互不相同。</p>
<p>这种性质的测试点再一次启发我们求理论上界：最优情况下，前面 <span class="math inline">\(50\)</span> 个方程同时满足，后面的 <span class="math inline">\(50\)</span> 组方程每组都满足 <span class="math inline">\(1\)</span> 个，最多可以满足 <span class="math inline">\(100\)</span> 个。如果答案是 <span class="math inline">\(100\)</span> 个的话，显然每个 <span class="math inline">\(x_j\)</span> 要从 <span class="math inline">\(j\)</span> 这一组 <span class="math inline">\(3\)</span> 个方程中取一个 <span class="math inline">\(c_i\)</span> 作为 <span class="math inline">\(x_j\)</span>，同时必须满足前面的 <span class="math inline">\(50\)</span> 个方程。</p>
<p>暴搜需要枚举 <span class="math inline">\(3^{50}\)</span> 种情况，不可能跑出来。注意到一个性质：模数 <span class="math inline">\(176400\)</span> 比较小，可以直接DP，比如可以这么做：记 <span class="math inline">\(f(i,j)\)</span> 为能否取前 <span class="math inline">\(i\)</span> 个 <span class="math inline">\(x\)</span> 的值使得 <span class="math inline">\(a_{0,0}x_0+a_{0,1}x_1+...+a_{0,i-1}x_{i-1}\equiv j\pmod 176400\)</span>，用 <span class="math inline">\(x_{i,0},x_{i,1},x_{i,2}\)</span> 表示 <span class="math inline">\(x_i\)</span> 的三种可能取值，则</p>
<p><span class="math display">\[f(i,j)=\begin{cases}[j=0],&amp;i=0\\f(i-1,(j-x_{i-1,0})\bmod 176400)\lor f(i-1,(j-x_{i-1,1})\bmod 176400)\lor f(i-1,(j-x_{i-1,2}),&amp;i&gt;0\bmod 176400)\end{cases}\]</span></p>
<p>当然也可以倒着定义，等等。根据DP推出的结果也就能得到方案。时间效率 <span class="math inline">\(50\times 176400\times 3\)</span>。</p>
<h4 id="测试点8">测试点8</h4>
<p>该测试点满足 <span class="math inline">\(n=m=50\)</span>，所有的 <span class="math inline">\(b_i\)</span> 为不超过 <span class="math inline">\(2^31\)</span> 的正整数。</p>
<p>乍一看和测试点6做法一样，然而还是有些区别的，因为联立方程组以后高斯消元发现无解了。</p>
<p>不过，导致无解的方程很少，可以从 <span class="math inline">\(m\)</span> 开始倒着枚举答案 <span class="math inline">\(a=m,m-1,m-2,...\)</span>，再枚举这 <span class="math inline">\(m\)</span> 个方程中大小为 <span class="math inline">\(m-a\)</span> 的子集，把这 <span class="math inline">\(m-a\)</span> 个方程删掉以后调用测试点6的程序。实验表明这个测试点的答案是 <span class="math inline">\(49\)</span>，所以只要调不超过 <span class="math inline">\(50\)</span> 次测试点6的程序就能解决了。</p>
<h4 id="测试点9">测试点9</h4>
<p>该测试点满足 <span class="math inline">\(n=1,m=100\)</span>，所有 <span class="math inline">\(a_i=1,b_i=19337\)</span>。</p>
<p>这个点最简单，和测试点1一样枚举就好了，时间效率 <span class="math inline">\(100\times 19337\)</span>。更简单的做法是统计出现次数最多的 <span class="math inline">\(c_i\)</span> 就是答案，时间效率可以做到 <span class="math inline">\(19337\)</span> 或者 <span class="math inline">\(100\times\log_2 100\)</span>。</p>
<h4 id="测试点10">测试点10</h4>
<p>该测试点满足 <span class="math inline">\(n=50,m=90\)</span>，所有的 <span class="math inline">\(b_i\)</span> 为不超过 <span class="math inline">\(2^31\)</span> 的正整数。</p>
<p>最难通过的一个测试点。</p>
<p>虽然 <span class="math inline">\(b_i\)</span> 还是可以像测试点6或者8那样分解，质因数不超过 <span class="math inline">\(1000\)</span>，但是这个方程组不能同时满足，并且倒着枚举答案并不能枚举出来。</p>
<p>这个问题相当于从 <span class="math inline">\(m\)</span> 个方程中取出尽量多个方程，使得它们能被同时满足。如果直接枚举的话复杂度是 <span class="math inline">\(O(2^m)\)</span>，不可能枚举出来。</p>
<p>用一些随机化乱搞可以得到很高的分数。我一开始使用的方法是：把 <span class="math inline">\(m\)</span> 个方程随机打乱，一开始 <span class="math inline">\(S=\varnothing\)</span>，然后贪心地逐个方程加入集合 <span class="math inline">\(S\)</span>，如果加入后 <span class="math inline">\(S\)</span> 不能满足，就不加入，多次随机取最优解。这样可以很容易地求出 <span class="math inline">\(33\)</span> 的答案，能得到9分。</p>
<p>之后，为了得到最后的1分，我花了一个晚上时间。</p>
<p>想过一种优化，构造无向图 <span class="math inline">\(G=(V,E)\)</span>，其中 <span class="math inline">\(V=\{0,1,...,m-1\}\)</span>，<span class="math inline">\((i,j)\in E\)</span> 当且仅当方程 <span class="math inline">\(i\)</span> 和方程 <span class="math inline">\(j\)</span> 不能被同时满足。这样如果 <span class="math inline">\(S\)</span> 是一个合法解，那么 <span class="math inline">\(S\)</span> 必然是 <span class="math inline">\(G\)</span> 的一个独立集。</p>
<p>接着我把图 <span class="math inline">\(G\)</span> 构出来，结果写了个程序发现怎么 <span class="math inline">\(E=\varnothing\)</span>？怀疑了一会儿感觉没什么救，就去看了题解，发现题解也是构了这个图，那一定是我写错了。然后就发现有个地方 <code>for(int j=0;j&lt;m;j++)</code> 的 <code>m</code> 打成了 <code>2</code>。哎我这么这么菜。然后开始搜 <span class="math inline">\(G\)</span> 的独立集，每次枚举剩下的图中度数最大的点选不选，很快搜到了 <span class="math inline">\(32\)</span> 左右的解，这时输出答案结果过不了 <code>checker</code>，又怀疑了一会儿人生，最后手算了一下发现我不仅图又构错了，搜索还打错了= =b</p>
<p>问题在于回溯的时候撤销的顺序错了。改完以后搜出了 <span class="math inline">\(32\)</span>，是对的，但是搜不动了。于是加了个优化：如果最大度数不超过 <span class="math inline">\(2\)</span>，那么贪心地选度数最小的点。又搜了一段时间搜出了 <span class="math inline">\(34\)</span>。</p>
<p>验证了一下这个 <span class="math inline">\(34\)</span> 的解发现是对的，于是就通过了。之后我继续搜，并没有搜出大于 <span class="math inline">\(34\)</span> 的解，因此这应该就是最优的了。不过这里我用的是猜想结合验证的方法，我不知道如何证明或证否 <span class="math inline">\(G\)</span> 的一个独立集必定是一组合法解。即：<strong>如果一个 <span class="math inline">\(n\)</span> 元一次同余方程组的任意两个方程都能同时被满足，那么这个方程组能被满足，这个性质我不会证明或证否</strong>。如果大家有什么好的思路欢迎提出。</p>
<p>代码如下，由于包含了10个点，代码巨长无比，大概 <span class="math inline">\(6\texttt{KB}\)</span>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OP(i) freopen(<span class="meta-string">"sports"</span>i<span class="meta-string">".in"</span>,<span class="meta-string">"r"</span>,stdin);freopen(<span class="meta-string">"sports"</span>i<span class="meta-string">".out"</span>,<span class="meta-string">"w"</span>,stdout);fprintf(stderr,<span class="meta-string">"Task "</span>i<span class="meta-string">"\n"</span>);read();</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP(i,j,k) memcpy(i,j,sizeof(k))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 1000000000</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swp</span><span class="params">(<span class="keyword">int</span>&amp;a,<span class="keyword">int</span>&amp;b)</span></span>&#123;<span class="keyword">int</span> t=a;a=b;b=t;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?gcd(b,a%b):a;&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> a==<span class="number">1</span>?<span class="number">1</span>:(<span class="number">1</span>+p*(a-inv(p%a,a)))/a%p;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bigint</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">1010</span>],l;</span><br><span class="line">	bigint(<span class="keyword">int</span> x=<span class="number">0</span>)&#123;</span><br><span class="line">		*a=x%BASE;a[l=<span class="number">1</span>]=<span class="number">0</span>;x/=BASE;</span><br><span class="line">		<span class="keyword">for</span>(;x;a[++l]=<span class="number">0</span>)a[l]=x%BASE,x/=BASE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fix</span><span class="params">()</span></span>&#123;<span class="keyword">while</span>(l&gt;<span class="number">1</span>&amp;&amp;!a[l<span class="number">-1</span>])l--;&#125;</span><br><span class="line">	bigint <span class="keyword">operator</span>+(bigint b)&#123;</span><br><span class="line">		bigint r;<span class="keyword">int</span> c=<span class="number">0</span>;<span class="built_in">memset</span>(r.a,<span class="number">0</span>,(r.l=(l&gt;b.l?l:b.l)+<span class="number">1</span>)*<span class="number">4</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r.l;i++)r.a[i]=(c+=(i&lt;l?a[i]:<span class="number">0</span>)+(i&lt;b.l?b.a[i]:<span class="number">0</span>))%BASE,c/=BASE;</span><br><span class="line">		r.fix();<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	bigint <span class="keyword">operator</span>*(bigint b)&#123;</span><br><span class="line">		bigint r;ll c;<span class="built_in">memset</span>(r.a,<span class="number">0</span>,(r.l=l+b.l)*<span class="number">4</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=c=<span class="number">0</span>;j&lt;=b.l;j++)r.a[i+j]=(c+=r.a[i+j]+<span class="number">1l</span>l*a[i]*b.a[j])%BASE,c/=BASE;</span><br><span class="line">		r.fix();<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">operator</span>%(<span class="keyword">int</span> b)&#123;</span><br><span class="line">		ll c=<span class="number">0</span>;<span class="keyword">for</span>(<span class="keyword">int</span> i=l;i--;)c=(c*BASE+a[i])%b;</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>,a[l<span class="number">-1</span>]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=l<span class="number">-1</span>;i--;)<span class="built_in">printf</span>(<span class="string">"%09d"</span>,a[i]);<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n,m,a[<span class="number">5010</span>][<span class="number">310</span>],b[<span class="number">5010</span>],c[<span class="number">5010</span>],x[<span class="number">5010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,a[i]+j);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,b+i,c+i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,x[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=m,s;i--;)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=s=<span class="number">0</span>;j&lt;n;j++)s=(s+<span class="number">1l</span>l*a[i][j]*x[j])%b[i];</span><br><span class="line">		<span class="keyword">if</span>(s==c[i])cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">eli</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p=*b,r=<span class="number">0</span>,i=<span class="number">0</span>,j,k;</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=r;j&lt;m&amp;&amp;!a[j][i];j++);</span><br><span class="line">		<span class="keyword">if</span>(j==m)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(k=i;k&lt;n;k++)swp(a[j][k],a[r][k]);swp(c[j],c[r]);</span><br><span class="line">		<span class="keyword">for</span>(j=r+<span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">			ll t=(p-a[j][i])*inv(a[r][i],p)%p;</span><br><span class="line">			<span class="keyword">for</span>(k=i;k&lt;n;k++)a[j][k]=(a[j][k]+a[r][k]*t)%p;</span><br><span class="line">			c[j]=(c[j]+c[r]*t)%p;</span><br><span class="line">		&#125;</span><br><span class="line">		r++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=r;i&lt;m;i++)<span class="keyword">if</span>(c[i])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=r;i--;)&#123;</span><br><span class="line">		<span class="keyword">for</span>(k=<span class="number">0</span>;!a[i][k];k++);x[k]=c[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=n;--j&gt;k;)x[k]=(x[k]+(p-a[i][j])*<span class="number">1l</span>l*x[j])%p;</span><br><span class="line">		x[k]=x[k]*inv(a[i][k],p)%p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt,max=<span class="number">0</span>,maxx;</span><br><span class="line">	<span class="keyword">for</span>(*x=<span class="number">0</span>;*x&lt;*b;++*x)(cnt=check())&gt;max?max=cnt,maxx=*x:<span class="number">1</span>;</span><br><span class="line">	*x=maxx;print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> A[<span class="number">50</span>],B[<span class="number">50</span>],cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)<span class="keyword">if</span>(c[i]%gcd(*a[i],b[i])==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> g=gcd(*a[i],b[i]);</span><br><span class="line">		A[cnt]=c[i]/g*inv(*a[i]/g,b[i])%b[i];</span><br><span class="line">		B[cnt++]=b[i];</span><br><span class="line">	&#125;</span><br><span class="line">	bigint ans=<span class="number">0</span>,P;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=cnt;i--;)&#123;</span><br><span class="line">		P=<span class="number">1</span>;<span class="keyword">for</span>(<span class="keyword">int</span> j=cnt;j--;)<span class="keyword">if</span>(j!=i)P=P*B[j];</span><br><span class="line">		ans=ans+P*inv(P%B[i],B[i])*A[i];</span><br><span class="line">	&#125;</span><br><span class="line">	ans.print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task3</span><span class="params">()</span></span>&#123;</span><br><span class="line">	eli();print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task4</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p=*b,B=<span class="number">40</span>,cnt,max=<span class="number">0</span>,xs[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> S=<span class="number">1</span>&lt;&lt;n;S--;)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=n,l;i--;)&#123;</span><br><span class="line">			x[i]=c[l=i*B+(S&gt;&gt;i&amp;<span class="number">1</span>)];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=n;--j&gt;i;)x[i]=(x[i]+(p-a[l][j])*<span class="number">1l</span>l*x[j])%p;</span><br><span class="line">			x[i]=x[i]*inv(a[l][i],p)%p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>((cnt=check())&gt;max?max=cnt:<span class="number">0</span>)CP(xs,x,xs);</span><br><span class="line">	&#125;</span><br><span class="line">	CP(x,xs,xs);print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task5</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p=*b,q=p,pr[<span class="number">20</span>],cnt=<span class="number">0</span>,A[<span class="number">100</span>][<span class="number">310</span>],B[<span class="number">100</span>],tx[<span class="number">20</span>][<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;<span class="number">1l</span>l*i*i&lt;=q;i++)q%i?<span class="number">1</span>:q/=(pr[cnt++]=i);</span><br><span class="line">	q&gt;<span class="number">1</span>?pr[cnt++]=q:<span class="number">1</span>;</span><br><span class="line">	CP(A,a,A);CP(B,c,B);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> t=cnt;t--;)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=m;i--;c[i]=B[i]%pr[t])</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=n;j--;)a[i][j]=A[i][j]%pr[t];</span><br><span class="line">		*b=pr[t];eli();<span class="built_in">memcpy</span>(tx[t],x,n*<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n,s;i--;x[i]=s)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> t=s=<span class="number">0</span>;t&lt;cnt;t++)s=(s+p/pr[t]*inv(p/pr[t]%pr[t],pr[t])%p*tx[t][i])%p;</span><br><span class="line">	print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">task6</span><span class="params">(<span class="keyword">bool</span> op=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> vis[<span class="number">1010</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> M=m,pr[<span class="number">1010</span>],cnt=<span class="number">0</span>,A[<span class="number">90</span>][<span class="number">310</span>],B[<span class="number">90</span>],C[<span class="number">90</span>],tx[<span class="number">1010</span>][<span class="number">90</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> q=b[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;<span class="number">1l</span>l*j*j&lt;=q;j++)</span><br><span class="line">			<span class="keyword">if</span>(q%j==<span class="number">0</span>)q/=j,vis[j]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(q&gt;<span class="number">1</span>)vis[q]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)<span class="keyword">if</span>(vis[i])pr[cnt++]=i;</span><br><span class="line">	CP(A,a,A);CP(B,b,B);CP(C,c,C);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> t=cnt;t--;)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=m=<span class="number">0</span>;i&lt;M;i++)<span class="keyword">if</span>(B[i]%pr[t]==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=n;j--;)a[m][j]=A[i][j]%pr[t];</span><br><span class="line">			c[m++]=C[i]%pr[t];</span><br><span class="line">		&#125;</span><br><span class="line">		*b=pr[t];<span class="keyword">if</span>(!eli())<span class="keyword">return</span>!(CP(a,A,A),CP(b,B,B),CP(c,C,C),m=M);<span class="built_in">memcpy</span>(tx[t],x,n*<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(op)<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		bigint S=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;cnt;t++)&#123;</span><br><span class="line">			bigint P=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt;j++)<span class="keyword">if</span>(j!=t)P=P*pr[j];</span><br><span class="line">			S=S+P*inv(P%pr[t],pr[t])*tx[t][i];</span><br><span class="line">		&#125;</span><br><span class="line">		S.print();</span><br><span class="line">	&#125;</span><br><span class="line">	CP(a,A,A);CP(b,B,B);CP(c,C,C);<span class="keyword">return</span> m=M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task7</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p=*b;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">bool</span> f[<span class="number">55</span>][<span class="number">176400</span>];</span><br><span class="line">	f[n][*c]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i--;)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;p;j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)f[i][j]|=f[i+<span class="number">1</span>][(j+c[n+<span class="number">3</span>*i+k]*<span class="number">1l</span>l*a[<span class="number">0</span>][i])%p];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,t;i&lt;n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)<span class="keyword">if</span>(f[i+<span class="number">1</span>][t=(j+c[n+<span class="number">3</span>*i+k]*<span class="number">1l</span>l*a[<span class="number">0</span>][i])%p])&#123;x[i]=c[n+<span class="number">3</span>*i+k];j=t;<span class="keyword">break</span>;&#125;</span><br><span class="line">	print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task8</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=--m;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)swp(a[i][j],a[m][j]);swp(b[i],b[m]);swp(c[i],c[m]);</span><br><span class="line">		<span class="keyword">if</span>(task6())<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task9</span><span class="params">()</span></span>&#123;task1();&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>&#123;</span></span><br><span class="line">	<span class="keyword">bool</span> G[<span class="number">90</span>][<span class="number">90</span>];<span class="keyword">int</span> vis[<span class="number">90</span>],S[<span class="number">90</span>],ans,ansS[<span class="number">90</span>];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> M=m;m=<span class="number">2</span>;ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;G[i][i]=vis[i]=S[i]=<span class="number">0</span>,i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;M;j++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)swp(a[i][k],a[<span class="number">0</span>][k]),swp(a[j][k],a[<span class="number">1</span>][k]);</span><br><span class="line">				swp(b[i],b[<span class="number">0</span>]);swp(c[i],c[<span class="number">0</span>]);swp(b[j],b[<span class="number">1</span>]);swp(c[j],c[<span class="number">1</span>]);</span><br><span class="line">				G[i][j]=G[j][i]=!task6(<span class="number">0</span>);</span><br><span class="line">				swp(b[j],b[<span class="number">1</span>]);swp(c[j],c[<span class="number">1</span>]);swp(b[i],b[<span class="number">0</span>]);swp(c[i],c[<span class="number">0</span>]);</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)swp(a[j][k],a[<span class="number">1</span>][k]),swp(a[i][k],a[<span class="number">0</span>][k]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		m=M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> dep,<span class="keyword">int</span> rest)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep&gt;ans)ans=dep,CP(ansS,S,S);</span><br><span class="line">		<span class="keyword">int</span> e=dep+rest;</span><br><span class="line">		<span class="keyword">if</span>(e&lt;=ans)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> maxd=<span class="number">-1</span>,maxi=<span class="number">-1</span>,mind=<span class="number">1</span>&lt;&lt;<span class="number">30</span>,mini;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=m,d;i--;)<span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=d=<span class="number">0</span>;j&lt;m;j++)d+=!vis[j]&amp;&amp;G[i][j];</span><br><span class="line">			<span class="keyword">if</span>(d&gt;maxd)maxd=d,maxi=i;</span><br><span class="line">			<span class="keyword">if</span>(d&lt;mind)mind=d,mini=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(maxi&gt;<span class="number">-1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(maxd&lt;=<span class="number">2</span>)maxi=mini;</span><br><span class="line">			vis[maxi]++?<span class="number">1</span>:rest--;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)<span class="keyword">if</span>(G[maxi][j])vis[j]++?<span class="number">1</span>:rest--;</span><br><span class="line">			S[maxi]=<span class="number">1</span>;dfs(dep+<span class="number">1</span>,rest);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)<span class="keyword">if</span>(G[maxi][j])--vis[j]?<span class="number">1</span>:rest++;</span><br><span class="line">			<span class="keyword">if</span>(maxd&lt;=<span class="number">2</span>||e&lt;=ans)&#123;S[maxi]=<span class="number">0</span>;vis[maxi]--;<span class="keyword">return</span>;&#125;</span><br><span class="line">			S[maxi]=<span class="number">0</span>;dfs(dep,rest);vis[maxi]--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;graph;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task10</span><span class="params">()</span></span>&#123;</span><br><span class="line">	graph.make();graph.dfs(<span class="number">0</span>,m);</span><br><span class="line">	<span class="keyword">int</span> M=m;m=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)<span class="keyword">if</span>(graph.ansS[i])&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)swp(a[i][j],a[m][j]);swp(b[i],b[m]);swp(c[i],c[m++]);</span><br><span class="line">	&#125;</span><br><span class="line">	task6();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	OP(<span class="string">"1"</span>);task1();</span><br><span class="line">	OP(<span class="string">"2"</span>);task2();</span><br><span class="line">	OP(<span class="string">"3"</span>);task3();</span><br><span class="line">	OP(<span class="string">"4"</span>);task4();</span><br><span class="line">	OP(<span class="string">"5"</span>);task5();</span><br><span class="line">	OP(<span class="string">"6"</span>);task6();</span><br><span class="line">	OP(<span class="string">"7"</span>);task7();</span><br><span class="line">	OP(<span class="string">"8"</span>);task8();</span><br><span class="line">	OP(<span class="string">"9"</span>);task9();</span><br><span class="line">	OP(<span class="string">"10"</span>);task10();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#top">返回顶部</a></p>
<hr>
<h3 id="后话">后话</h3>
<p>WC前刷了这么多题，也改变不了我是个无实力的暴力选手的事实。</p>
<p>最后，WC交了几个暴力上去，提交答案题也完全切不动，就这么跪了。</p>
<p>实力的提升，并不是靠做几道题就能积累起来的。</p>
<p><a href="#top">返回顶部</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/02/03/before-wc2017/" data-id="cjegzidd2000kdf1lc1pr2e3n" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/记录/">记录</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/题解/">题解</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/02/08/wc2017/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          WC2017 暴力之战
        
      </div>
    </a>
  
  
    <a href="/2017/01/26/goodbye-bingshen/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">记一次冒险的举动——Goodbye Bingshen</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/51nod/">51nod</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/APIO/">APIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AtCoder/">AtCoder</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTSC/">CTSC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Codechef/">Codechef</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Codeforces/">Codeforces</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FJOI/">FJOI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FJWC/">FJWC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HNOI/">HNOI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IOI/">IOI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LYDSY/">LYDSY</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NOI/">NOI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SDOI/">SDOI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SHOI/">SHOI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TopCoder/">TopCoder</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UOJ/">UOJ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WC/">WC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ZJOI/">ZJOI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/总结/">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板/">模板</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/清华集训/">清华集训</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/百度之星/">百度之星</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/省队集训/">省队集训</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/记录/">记录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/酱油记/">酱油记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/集训队互测/">集训队互测</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/题解/">题解</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/51nod/" style="font-size: 16.25px;">51nod</a> <a href="/tags/APIO/" style="font-size: 12.5px;">APIO</a> <a href="/tags/AtCoder/" style="font-size: 10px;">AtCoder</a> <a href="/tags/CTSC/" style="font-size: 11.25px;">CTSC</a> <a href="/tags/Codechef/" style="font-size: 10px;">Codechef</a> <a href="/tags/Codeforces/" style="font-size: 15px;">Codeforces</a> <a href="/tags/FJOI/" style="font-size: 12.5px;">FJOI</a> <a href="/tags/FJWC/" style="font-size: 10px;">FJWC</a> <a href="/tags/HNOI/" style="font-size: 10px;">HNOI</a> <a href="/tags/IOI/" style="font-size: 10px;">IOI</a> <a href="/tags/LYDSY/" style="font-size: 11.25px;">LYDSY</a> <a href="/tags/NOI/" style="font-size: 12.5px;">NOI</a> <a href="/tags/SDOI/" style="font-size: 10px;">SDOI</a> <a href="/tags/SHOI/" style="font-size: 10px;">SHOI</a> <a href="/tags/TopCoder/" style="font-size: 10px;">TopCoder</a> <a href="/tags/UOJ/" style="font-size: 13.75px;">UOJ</a> <a href="/tags/WC/" style="font-size: 10px;">WC</a> <a href="/tags/ZJOI/" style="font-size: 10px;">ZJOI</a> <a href="/tags/总结/" style="font-size: 17.5px;">总结</a> <a href="/tags/模板/" style="font-size: 10px;">模板</a> <a href="/tags/清华集训/" style="font-size: 11.25px;">清华集训</a> <a href="/tags/百度之星/" style="font-size: 10px;">百度之星</a> <a href="/tags/省队集训/" style="font-size: 11.25px;">省队集训</a> <a href="/tags/记录/" style="font-size: 11.25px;">记录</a> <a href="/tags/酱油记/" style="font-size: 20px;">酱油记</a> <a href="/tags/集训队互测/" style="font-size: 10px;">集训队互测</a> <a href="/tags/题解/" style="font-size: 18.75px;">题解</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/12/04/lydsy-3489/">LYDSY P3489 题解</a>
          </li>
        
          <li>
            <a href="/2017/10/29/codeforces-443/">Codeforces Round 443 总结</a>
          </li>
        
          <li>
            <a href="/2017/10/22/astar2017/">百度之星Astar决赛被虐记</a>
          </li>
        
          <li>
            <a href="/2017/10/15/codeforces-440/">Codeforces Round 440 总结</a>
          </li>
        
          <li>
            <a href="/2017/10/09/atcoder-codefestival2017-qualb/">AtCoder CODE FESTIVAL 2017 qual B 总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 j324h9<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>