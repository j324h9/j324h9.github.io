<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  <%
  var title = page.title;

  if (is_archive()){
    title = __('archive_a');

    if (is_month()){
      title += ': ' + page.year + '/' + page.month;
    } else if (is_year()){
      title += ': ' + page.year;
    }
  } else if (is_category()){
    title = __('category') + ': ' + page.category;
  } else if (is_tag()){
    title = __('tag') + ': ' + page.tag;
  }
  %>
  <title><% if (title){ %><%= title %> | <% } %><%= config.title %></title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<!--
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
        },
        "HTML-CSS": { availableFonts: ["TeX"] }
    });
  </script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
-->
  <%- open_graph({twitter_id: theme.twitter, google_plus: theme.google_plus, fb_admins: theme.fb_admins, fb_app_id: theme.fb_app_id}) %>
  <% if (theme.rss){ %>
    <link rel="alternate" href="<%- theme.rss %>" title="<%= config.title %>" type="application/atom+xml">
  <% } %>
  <% if (theme.favicon){ %>
    <link rel="icon" href="<%- theme.favicon %>">
  <% } %>
  <% if (config.highlight.enable){ %>
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <% } %>
  <%- css('css/style') %>
  <%- partial('google-analytics') %><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">oi_loser&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-hnoi2017-record" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/26/hnoi2017-record/" class="article-date">
  <time datetime="2017-04-26T02:15:14.000Z" itemprop="datePublished">2017-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      HNOI2017做题记录
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>除了迷之D2T2以外难度十分正常，不会太难，D1具有可AK性。代码量也很正常，都在1KB到2KB之间。<del>虽然D1考点有点偏？不过反正比HNOI2016好</del></p>
<h4 id="d1t1单旋">D1T1：单旋</h4>
<p>这题本来很简单的，然而我卡了很久= =因为我读错题了！以为要旋任意结点，然后思博了一个多小时，越想越复杂……等我写了个暴力，考虑暴力怎么卡的时候，才发现只要求旋最小/最大就行了。。。</p>
<p>那么就是个线段树/树状数组练习题。。。</p>
<p>考虑几个操作对树的形态和深度的变化：</p>
<p>插入 <span class="math inline">\(x\)</span>，则 <span class="math inline">\(x\)</span> 的深度为其父结点加 <span class="math inline">\(1\)</span>。</p>
<p>把最小/最大值结点 <span class="math inline">\(x\)</span> 旋到根，相当于 <span class="math inline">\(x\)</span> 的父结点到根这一段看成一个结点，旋转 <span class="math inline">\(x\)</span> 一次。那么 <span class="math inline">\(x\)</span> 的深度变成 <span class="math inline">\(1\)</span>，<span class="math inline">\(x\)</span> 子树内结点深度不变，其余结点深度加 <span class="math inline">\(1\)</span>。</p>
<p>删除根 <span class="math inline">\(x\)</span>，则所有结点的深度减 <span class="math inline">\(1\)</span>。</p>
<p>将所有的键值 <span class="math inline">\(key\)</span> 排序，根据二叉排序树的性质，不论怎么旋转，树的中序遍历都是 <span class="math inline">\(key\)</span> 的递增序。并且在中序遍历中，一个子树对应一段连续区间，因此对所有结点的 <span class="math inline">\(key\)</span> 递增序建线段树或树状数组，即可维护结点深度。</p>
<p>另外考虑一个问题，如何确定插入结点 <span class="math inline">\(x\)</span> 的父结点 <span class="math inline">\(y\)</span>。假如 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(y\)</span> 的左子结点，那么 <span class="math inline">\(y\)</span> 是最小的比 <span class="math inline">\(x\)</span> 大的结点；反之，<span class="math inline">\(y\)</span> 是最大的比 <span class="math inline">\(x\)</span> 小的结点。用线段树维护当前树上结点，支持查询前驱后继即可。我比较懒直接拉了个STL的 <code>set</code>……</p>
<p>复杂度 <span class="math inline">\(O(m\log m)\)</span>。注意特判根的情况（如果用比较好的写法可能不用判）。代码有点长，快2KB了：</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> m,op[<span class="number">100010</span>],sz;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> id,key;</span><br><span class="line">	node*fa,*ch[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp;x)<span class="keyword">const</span>&#123;<span class="keyword">return</span> key&lt;x.key;&#125;</span><br><span class="line">&#125;nodes[<span class="number">100010</span>],*cur[<span class="number">100010</span>],*root;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;node&gt;S;</span><br><span class="line"><span class="keyword">int</span> dep[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">for</span>(;i&lt;=sz;i+=i&amp;-i)dep[i]+=x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="keyword">int</span> s=<span class="number">0</span>;<span class="keyword">for</span>(;i;i-=i&amp;-i)s+=dep[i];<span class="keyword">return</span> s;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rot_min</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=S.begin()-&gt;id,d=query(i);</span><br><span class="line">	node*x=nodes+i;</span><br><span class="line">	<span class="keyword">if</span>(x==root)<span class="keyword">return</span> d;</span><br><span class="line">	add(i,<span class="number">1</span>-d);add(i+<span class="number">1</span>,d<span class="number">-1</span>);add(x-&gt;fa-&gt;id,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(x-&gt;fa-&gt;ch[<span class="number">0</span>]=x-&gt;ch[<span class="number">1</span>])x-&gt;ch[<span class="number">1</span>]-&gt;fa=x-&gt;fa;</span><br><span class="line">	x-&gt;ch[<span class="number">1</span>]=root;x-&gt;fa=<span class="number">0</span>;root-&gt;fa=x;root=x;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rot_max</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=S.rbegin()-&gt;id,d=query(i);</span><br><span class="line">	node*x=nodes+i;</span><br><span class="line">	<span class="keyword">if</span>(x==root)<span class="keyword">return</span> d;</span><br><span class="line">	add(i,<span class="number">1</span>-d);add(i+<span class="number">1</span>,d<span class="number">-1</span>);add(<span class="number">1</span>,<span class="number">1</span>);add(x-&gt;fa-&gt;id+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span>(x-&gt;fa-&gt;ch[<span class="number">1</span>]=x-&gt;ch[<span class="number">0</span>])x-&gt;ch[<span class="number">0</span>]-&gt;fa=x-&gt;fa;</span><br><span class="line">	x-&gt;ch[<span class="number">0</span>]=root;x-&gt;fa=<span class="number">0</span>;root-&gt;fa=x;root=x;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,op+i);</span><br><span class="line">		<span class="keyword">if</span>(op[i]==<span class="number">1</span>)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;nodes[++sz].key),nodes[sz].id=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::sort(nodes+<span class="number">1</span>,nodes+sz+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sz;i++)cur[nodes[i].id]=nodes+i,nodes[i].id=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(op[i]==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">set</span>&lt;node&gt;::iterator it=S.insert(*cur[i]).first;</span><br><span class="line">			<span class="keyword">int</span> f=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(it!=S.begin())it--,nodes[it-&gt;id].ch[<span class="number">1</span>]?<span class="number">0</span>:nodes[f=it-&gt;id].ch[<span class="number">1</span>]=cur[i],it++;</span><br><span class="line">			it++;it==S.end()||nodes[it-&gt;id].ch[<span class="number">0</span>]?<span class="number">0</span>:nodes[f=it-&gt;id].ch[<span class="number">0</span>]=cur[i];it--;</span><br><span class="line">			<span class="keyword">int</span> fd=<span class="number">1</span>,td=query(cur[i]-&gt;id);</span><br><span class="line">			<span class="keyword">if</span>(f)cur[i]-&gt;fa=nodes+f,fd+=query(f);</span><br><span class="line">			<span class="keyword">else</span> root=cur[i];</span><br><span class="line">			add(cur[i]-&gt;id,fd-td);</span><br><span class="line">			add(cur[i]-&gt;id+<span class="number">1</span>,td-fd);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,fd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op[i]%<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,rot_max());</span><br><span class="line">			<span class="keyword">if</span>(op[i]&gt;<span class="number">3</span>)S.erase(*root),add(<span class="number">1</span>,<span class="number">-1</span>),add(root-&gt;id,<span class="number">1</span>),(root=root-&gt;ch[<span class="number">0</span>])?root-&gt;fa=<span class="number">0</span>:<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,rot_min());</span><br><span class="line">			<span class="keyword">if</span>(op[i]&gt;<span class="number">3</span>)S.erase(*root),add(root-&gt;id+<span class="number">1</span>,<span class="number">-1</span>),(root=root-&gt;ch[<span class="number">1</span>])?root-&gt;fa=<span class="number">0</span>:<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="d1t2影魔">D1T2：影魔</h4>
<p>CTSC那段时间immaotalCO给我看了这题，我想了很久的单调栈都没想清楚，还想到分块去了……现在想想当时真是SB。</p>
<p>记 <span class="math inline">\(v(l,r)=\max\{k_i|l\le i\le r\}\)</span>，<span class="math inline">\(\mathrm{last}_i=\min\{j\in\mathbf{N}|v(j+1,i-1) &lt; k_i\}\)</span>，<span class="math inline">\(\mathrm{next}_i=\max\{j\in\mathbf{N}|v(i+1,j-1)&lt; k_i\}\)</span>。last和next数组可以用单调栈 <span class="math inline">\(O(n)\)</span> 求出。</p>
<p>我们可以把区间 <span class="math inline">\([l,r]\)</span> 的答案 <span class="math inline">\(S[l,r]\)</span> 的式子写成这种形式：</p>
<p><span class="math display">\[S[l,r]=p_1\left(\sum_{\begin{array}{c}l\le i&lt; j\le r\\k_i&lt; k_j\end{array}}  [v_{i+1,j-1}&lt; k_i]+\sum_{\begin{array}{c}l\le i&lt; j\le r\\k_i&gt;k_j\end{array}}  [v_{i+1,j-1}&lt; k_j]\right)+p_2\left[\sum_{\begin{array}{c}l\le i&lt; j\le r\\k_i&lt; k_j\end{array}}  ([v_{i+1,j-1}&lt; k_j]-[v_{i+1,j-1}&lt; k_i])+\sum_{\begin{array}{c}l\le i&lt; j\le r\\k_i&gt;k_j\end{array}}  ([v_{i+1,j-1}&lt; k_i]-[v_{i+1,j-1}&lt; k_j])\right]\]</span></p>
<p>当然，可以化成这样：</p>
<p><span class="math display">\[S[l,r]=(p_1-p_2)\left(\sum_{l\le i&lt; j\le r,k_i&lt; k_j}  [v_{i+1,j-1}&lt; k_i]+\sum_{l\le i&lt; j\le r,k_i&gt;k_j}  [v_{i+1,j-1}&lt; k_j]\right)+p_2\left[\sum_{l\le i&lt; j\le r,k_i&lt; k_j}  [v_{i+1,j-1}&lt; k_j]+\sum_{l\le i&lt; j\le r,k_i&gt;k_j}  [v_{i+1,j-1}&lt; k_i]\right]\]</span></p>
<p>容易发现求 <span class="math inline">\(\sum_{l\le i&lt; j\le r,k_i&lt; k_j} [v_{i+1,j-1}&lt; k_i]\)</span> 这个式子是so easy的，因为 <span class="math inline">\(v_{i+1,j-1}&lt; k_i\)</span> 等价于 <span class="math inline">\(j\le\mathrm{next}_i\)</span>，而如果 <span class="math inline">\(j&lt;\mathrm{next}_i\)</span>，则 <span class="math inline">\(k_j&lt; k_i\)</span>，仅当 <span class="math inline">\(j=\mathrm{next}_i\)</span> 时 <span class="math inline">\(k_j&gt;k_i\)</span>，因此</p>
<p><span class="math display">\[\sum_{l\le i&lt; j\le r,k_i&lt; k_j}  [v_{i+1,j-1}&lt; k_i]=\sum_{i=l}^r[\mathrm{next}_i\le r]\]</span></p>
<p>同理</p>
<p><span class="math display">\[\sum_{l\le i&lt; j\le r,k_i&gt;k_j}  [v_{i+1,j-1}&lt; k_j]=\sum_{j=l}^r[\mathrm{last}_j\ge l]\]</span></p>
<p>类似的我们还可以继续推：</p>
<p><span class="math display">\[\sum_{l\le i&lt; j\le r,k_i&lt; k_j}[v_{i+1,j-1}&lt; k_j]=\sum_{\begin{array}{c}l\le i&lt; j\le r\\i&gt;\mathrm{last}_j\end{array}}1=\sum_{\begin{array}{c}l\le j\le r\\ \mathrm{last}_j&lt; l\end{array}}\sum_{i=l}^{j-1}1+\sum_{\begin{array}{c}l\le j\le r\\ \mathrm{last}_j\ge l\end{array}}\sum_{i=\mathrm{last}_j+1}^{j-1}1=\sum_{\begin{array}{c}l\le j\le r\\ \mathrm{last}_j&lt; l\end{array}}(j-l)+\sum_{\begin{array}{c}l\le j\le r\\ \mathrm{last}_j\ge l\end{array}}(j-\mathrm{last}_j-1)\]</span></p>
<p>同理</p>
<p><span class="math display">\[\sum_{l\le i&lt; j\le r,k_i&gt;k_j}[v_{i+1,j-1}&lt; k_i]=\sum_{\begin{array}{c}l\le i\le r\\ \mathrm{next}_i&gt;r\end{array}}(r-i)+\sum_{\begin{array}{c}l\le i\le r\\ \mathrm{next}_i\le r\end{array}}(\mathrm{next}_i-i-1)\]</span></p>
<p>询问这些式子的值很简单。以 <span class="math inline">\(\sum_{l\le i\le r,\mathrm{next}_i\le r}(\mathrm{next}_i-i-1)\)</span> 为例，可以将其拆成 <span class="math inline">\(\sum_{i\le r,\mathrm{next}_i\le r}(\mathrm{next}_i-i-1)-\sum_{i\le l-1,\mathrm{next}_i\le r}(\mathrm{next}_i-i-1)\)</span>。考虑 <span class="math inline">\(\sum_{i\le r,\mathrm{next}_i\le r}(\mathrm{next}_i-i-1)\)</span> 怎么求，这相当于一个二维偏序，可以离线树状数组解决，即：维护一个初始值为 <span class="math inline">\(0\)</span> 的序列 <span class="math inline">\(A\)</span>，按照 <span class="math inline">\(i=1,2,\cdots,n\)</span> 的顺序，将 <span class="math inline">\(A_{\mathrm{next}_i}\)</span> 的值加上 <span class="math inline">\(\mathrm{next}_i-i-1\)</span>，然后就可以更新 <span class="math inline">\(r=i\)</span> 的询问的答案为 <span class="math inline">\(A_1+A_2+\cdots+A_r\)</span>，树状数组维护。</p>
<p>复杂度 <span class="math inline">\(O(n+m\log n)\)</span>。代码比上一题简单。我想吐槽的是为什么HNOI2017D1出两道树状数组题。。。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200010</span>,maxm=<span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,p1,p2,k[maxn],stk[maxn],lst[maxn],nxt[maxn],a[maxn],b[maxn];</span><br><span class="line">ll B[<span class="number">6</span>][<span class="number">200010</span>],S[<span class="number">6</span>],ans[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">for</span>(S[t]+=x,i++;i&lt;=n+<span class="number">2</span>;i+=i&amp;-i)B[t][i]+=x;&#125;</span><br><span class="line"><span class="function">ll <span class="title">pre</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> i)</span></span>&#123;ll s=<span class="number">0</span>;<span class="keyword">for</span>(i++;i;i-=i&amp;-i)s+=B[t][i];<span class="keyword">return</span> s;&#125;</span><br><span class="line"><span class="function">ll <span class="title">pos</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> i)</span></span>&#123;<span class="keyword">return</span> S[t]-pre(t,i<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;Q[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;p1,&amp;p2);</span><br><span class="line">	<span class="keyword">int</span> top=<span class="number">0</span>;*k=k[n+<span class="number">1</span>]=n+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,k+i);k[stk[top]]&lt;k[i];top--);</span><br><span class="line">		lst[i]=stk[top];stk[++top]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	top=<span class="number">0</span>;*stk=n+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--)&#123;</span><br><span class="line">		<span class="keyword">while</span>(k[stk[top]]&lt;k[i])--top;</span><br><span class="line">		nxt[i]=stk[top];stk[++top]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,a+i,b+i);</span><br><span class="line">		Q[a[i]<span class="number">-1</span>].push_back(-i);Q[b[i]].push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,l,r;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i)add(<span class="number">0</span>,l=lst[i],<span class="number">1</span>),add(<span class="number">1</span>,r=nxt[i],<span class="number">1</span>),add(<span class="number">2</span>,l,i),add(<span class="number">3</span>,r,i),add(<span class="number">4</span>,l,i-l<span class="number">-1</span>),add(<span class="number">5</span>,r,r-i<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> q=Q[i].size(),t,j;q--;)&#123;</span><br><span class="line">			t=(j=Q[i][q])&lt;<span class="number">0</span>?j=-j,<span class="number">-1</span>:<span class="number">1</span>;l=a[j];r=b[j];</span><br><span class="line">			ans[j]+=t*((pos(<span class="number">0</span>,l)+pre(<span class="number">1</span>,r))*(p1-p2)+(pre(<span class="number">2</span>,l<span class="number">-1</span>)-pre(<span class="number">0</span>,l<span class="number">-1</span>)*l+pos(<span class="number">4</span>,l)-pos(<span class="number">3</span>,r+<span class="number">1</span>)+pos(<span class="number">1</span>,r+<span class="number">1</span>)*r+pre(<span class="number">5</span>,r))*p2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后看别人题解说这题和HNOI2016D2T1做法差不多，诶我的做法好像不一样啊，有空的时候交叉写一波？</p>
<h4 id="d1t3礼物">D1T3：礼物</h4>
<p>可能是D1最裸的题？</p>
<p>设 <span class="math inline">\(y\)</span> 顺时针转动了 <span class="math inline">\(d\)</span> 个位置，<span class="math inline">\(c\)</span> 表示对 <span class="math inline">\(x\)</span> 的增加量（如果对 <span class="math inline">\(y\)</span> 增加则用相反数），则差异值为（以下从 <span class="math inline">\(0\)</span> 开始标号）</p>
<p><span class="math display">\[\begin{align*}
\sum_{i=0}^{n-1}(x_i-y_{(i+d)\bmod n}+c)^2&amp;=&amp;\sum_{i=0}^{n-1}(x_i^2+y_{(i+d)\bmod n}^2-2x_iy_{(i+d)\bmod n}+c^2+2x_ic-2y_{(i+d)\bmod n}c)
\\&amp;=&amp;\sum_{i=0}^{n-1}x_i^2+\sum_{i=0}^{n-1}y_i^2-2\sum_{i=0}^{n-1}x_iy_{(i+d)\bmod n}+nc^2+2(\sum_{i=0}^{n-1}x_i-\sum_{i=0}^{n-1}y_i)c
\end{align*}\]</span></p>
<p>这样就会发现 <span class="math inline">\(d,c\)</span> 是独立的，可分开考虑。</p>
<p>先考虑最小化项 <span class="math inline">\(-2\sum_{i=0}^{n-1}x_iy_{(i+d)\bmod n}\)</span>，即最大化 <span class="math inline">\(\sum_{i=0}^{n-1}x_iy_{(i+d)\bmod n}\)</span>。设 <span class="math inline">\(y&#39;_i=y_{n-i-1}\)</span>，则 <span class="math display">\[\sum_{i=0}^{n-1}x_iy_{(i+d)\bmod n}=\sum_{i=0}^{n-1}x_iy&#39;_{(n-1-i-d)\bmod n}\]</span></p>
<p>不难看出这是一个卷积的形式，即设 <span class="math inline">\(f(d)=\sum_{i+j=d\lor i+j=d+n}x_iy&#39;_j\)</span>，则上式的值为 <span class="math inline">\(f(n-1-d)\)</span>。卷积可以用FFT计算，复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<p>再考虑最小化 <span class="math inline">\(nc^2+2(\sum_{i=0}^{n-1}x_i-\sum_{i=0}^{n-1}y_i)c\)</span>，这是一个关于 <span class="math inline">\(c\)</span> 的二次函数，令 <span class="math inline">\(c_0=-\frac{\sum_{i=0}^{n-1}x_i-\sum_{i=0}^{n-1}y_i}{n}\)</span>，则函数在 <span class="math inline">\((-\infty,c_0)\)</span> 上递减，在 <span class="math inline">\((c_0,+\infty)\)</span> 上递增，由于 <span class="math inline">\(c\)</span> 是整数（不一定非负，因为可以对另一个环增加），只要将不大于 <span class="math inline">\(c_0\)</span> 的最大整数和大于 <span class="math inline">\(c_0\)</span> 的最小整数 <span class="math inline">\(c\)</span> 代入函数，取较小值即可，复杂度为计算 <span class="math inline">\(\sum_{i=0}^{n-1}x_i-\sum_{i=0}^{n-1}y_i\)</span> 的复杂度，即 <span class="math inline">\(O(n)\)</span>。</p>
<p>总复杂度为 <span class="math inline">\(O(n\log n)\)</span>。为什么 <span class="math inline">\(n\le 50000\)</span>？为什么 <span class="math inline">\(m\le 100\)</span>？想想就会发现这样答案不会爆 <code>int</code>，出题人真良心。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1</span>&lt;&lt;<span class="number">17</span>,mod=<span class="number">998244353</span>;</span><br><span class="line">ll W[maxn];</span><br><span class="line"><span class="function">ll <span class="title">pw</span><span class="params">(ll a,ll b)</span></span>&#123;ll c=<span class="number">1</span>;<span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)b%<span class="number">2</span>?c=c*a%mod:<span class="number">1</span>,a=a*a%mod;<span class="keyword">return</span> c;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dft</span><span class="params">(<span class="keyword">int</span>*a,<span class="keyword">int</span> n,<span class="keyword">bool</span> r=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">	ll*w=W+n/<span class="number">2</span>;w[*w=<span class="number">1</span>]=pw(<span class="number">3</span>,(mod<span class="number">-1</span>)/n);</span><br><span class="line">	<span class="keyword">if</span>(r)w[<span class="number">1</span>]=pw(w[<span class="number">1</span>],mod<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n/<span class="number">2</span>;i++)w[i]=w[i<span class="number">-1</span>]*w[<span class="number">1</span>]%mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i--;)W[i]=W[i*<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,t;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;j)t=a[i],a[i]=a[j],a[j]=t;</span><br><span class="line">		<span class="keyword">for</span>(t=n/<span class="number">2</span>;(j^=t)&lt;t;t/=<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	w=W+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;w+=i,i*=<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j+=i&lt;&lt;<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>,t;k&lt;i;k++)</span><br><span class="line">				t=a[i+j+k]*w[k]%mod,a[i+j+k]=(a[j+k]+mod-t)%mod,(a[j+k]+=t)%=mod;</span><br><span class="line">	<span class="keyword">if</span>(!r)<span class="keyword">return</span>;</span><br><span class="line">	ll I=pw(n,mod<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)a[i]=a[i]*I%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,x[maxn],y[maxn],d,s,N,M;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;<span class="keyword">return</span>(n*c<span class="number">-2</span>*d)*c;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?a:b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%*d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,x+i),d-=x[i],s+=x[i]*x[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i--;)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,y+i),d+=y[i],s+=y[i]*y[i];</span><br><span class="line">	s+=min(f(d/n),min(f(d/n<span class="number">-1</span>),f(d/n+<span class="number">1</span>)));</span><br><span class="line">	<span class="keyword">for</span>(N=<span class="number">1</span>;N&lt;n*<span class="number">2</span>;N*=<span class="number">2</span>);</span><br><span class="line">	dft(x,N);dft(y,N);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)x[i]=x[i]*(ll)y[i]%mod;</span><br><span class="line">	dft(x,N,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)x[i]+x[i+n]&gt;M?M=x[i]+x[i+n]:<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,s<span class="number">-2</span>*M);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="d2t1大佬">D2T1：大佬</h4>
<p>好题，并不像之前听说的那样玄学。我们来分析一下。</p>
<p>首先在第 <span class="math inline">\(i\)</span> 天，如果我方自信值 <span class="math inline">\(C&#39;\ge 0\)</span>，设对方自信值为 <span class="math inline">\(C\)</span>，令变量 <span class="math inline">\(t\)</span> 的初始值为 <span class="math inline">\(0\)</span>，我们有五种可能的操作：</p>
<p>1、<span class="math inline">\(C\leftarrow C-1\)</span>；</p>
<p>2、<span class="math inline">\(C&#39;\leftarrow\min\{C&#39;+w_i,mc\}\)</span>；</p>
<p>3、<span class="math inline">\(L\leftarrow L+1\)</span>；</p>
<p>4、<span class="math inline">\(F\leftarrow FL\)</span>；</p>
<p>5、<span class="math inline">\(C\leftarrow C-F,L\leftarrow 0,F\leftarrow 1,t\leftarrow t+1\)</span>，如果 <span class="math inline">\(t &lt; 2\)</span>。</p>
<p>除了操作2以外的四种操作均和 <span class="math inline">\(i\)</span> 及 <span class="math inline">\(C&#39;\)</span> 无关，因此最后能否战胜取决于能分配多少天给这四个操作。</p>
<p>设计DP：<span class="math inline">\(f(i,c)\)</span> 表示前 <span class="math inline">\(i\)</span> 天的行动使第 <span class="math inline">\(i\)</span> 天结束后 <span class="math inline">\(C&#39;=c\)</span> 的所有方案中，最多能使用多少次非操作2。如果没有这样的方案，<span class="math inline">\(f(i,c)=-\infty\)</span>。显然 <span class="math inline">\(C&#39;\)</span> 只和什么时候使用操作2有关。考虑转移，枚举最后一天的操作，如果使用非操作2，那么上一天的自信值 <span class="math inline">\(c&#39;\)</span> 满足 <span class="math inline">\(c=c&#39;-a_i\)</span>；否则 <span class="math inline">\(c=\min\{c&#39;-a_i+w_i\}\)</span> 且 <span class="math inline">\(c&#39;-a_i\ge 0\)</span>。可以得到如下的状态转移方程：</p>
<p><span class="math display">\[f(i,c)=\max\left\{\max_{c&#39;}\{f(i-1,c&#39;)+1|c=c&#39;-a_i\},\max_{c&#39;}\{f(i-1,c&#39;)|c=\min\{c&#39;-a_i+w_i\},c&#39;-a_i\ge 0\}\right\}\]</span></p>
<p>其中 <span class="math inline">\(0\le i\le n\)</span>，<span class="math inline">\(0\le c\le mc\)</span>。实现时用顺推法即可，这一步的复杂度为 <span class="math inline">\(O(n\cdot mc)\)</span>。</p>
<p>令 <span class="math inline">\(T=\max_{i,c}\{f(i,c)\}\)</span>，则当对方自信值为 <span class="math inline">\(C\)</span> 时，能够战胜的条件是用不超过 <span class="math inline">\(T\)</span> 天时间进行操作1、3、4、5能够恰好把 <span class="math inline">\(C\)</span> 减到 <span class="math inline">\(0\)</span>。</p>
<p>考虑这个问题如何解决。</p>
<p>注意问题的突破口，操作5只能做不超过2次。先探究做恰好2次的情况。设2次操作5使用值的 <span class="math inline">\(F\)</span> 值分别为 <span class="math inline">\(F_1,F_2\)</span>，2次操作5前使用的操作3、4总次数分别为 <span class="math inline">\(T_1-1,T_2-1\)</span>（<span class="math inline">\(T_2\)</span> 不包含 <span class="math inline">\(T_1\)</span>），那么操作1可使用的天数不超过 <span class="math inline">\(T-T_1-T_2\)</span>，需要使用的次数为 <span class="math inline">\(C-F_1-F_2\)</span>，条件等价于</p>
<p><span class="math display">\[F_1+F_2\le C\]</span></p>
<p><span class="math display">\[C-F_1-F_2\le T-T_1-T_2\]</span></p>
<p>可以枚举 <span class="math inline">\(F_1,F_2\)</span>，然后找出两个<strong>用时最小</strong>的由3、4构成的操作序列 <span class="math inline">\(seq_1,seq_2\)</span>，满足从 <span class="math inline">\(L=0,F=1\)</span> 开始，如果做 <span class="math inline">\(seq_1\)</span> 则最后 <span class="math inline">\(F=F_1\)</span>，如果做 <span class="math inline">\(seq_2\)</span> 则最后 <span class="math inline">\(F=F_2\)</span>。</p>
<p>这里，我们预处理 <span class="math inline">\(T(F)\)</span> 为从 <span class="math inline">\(L=0,F=1\)</span> 开始，使用若干次操作3、4，最后用一次操作5，恰好使对方 <span class="math inline">\(C\)</span> 减少 <span class="math inline">\(F\)</span> 的操作方案中，操作3、4、5的使用次数之和的最小值，那么枚举 <span class="math inline">\(F_1,F_2\)</span>（满足 <span class="math inline">\(F_1+F_2\le C\)</span>）之后，只需判断是否有</p>
<p><span class="math display">\[C-F_1-F_2\le T-T(F_1)-T(F_2)\]</span></p>
<p>即可。</p>
<p>问题来了——<span class="math inline">\(C\)</span> 的范围是 <span class="math inline">\(10^8\)</span>，这意味着 <span class="math inline">\(F_1,F_2\)</span> 也可能达到 <span class="math inline">\(10^8\)</span>，暴力DP预处理 <span class="math inline">\(T(F)\)</span> 函数的复杂度太高，如何解决？</p>
<p>注意另一突破口：<span class="math inline">\(T\le n\le 100\)</span>，因此整个操作过程中 <span class="math inline">\(L\le T\le 100\)</span>，而 <span class="math inline">\(F\)</span> 是由操作过程中的若干个 <span class="math inline">\(L\)</span> 相乘得到，这说明 <span class="math inline">\(F\)</span> 一定可以由若干个不超过 <span class="math inline">\(100\)</span> 的正整数相乘得到，经过验证，这样的 <span class="math inline">\(F\)</span> 不到 <span class="math inline">\(10^6\)</span> 个。</p>
<p>我用的是BFS来预处理这些数 <span class="math inline">\(F\)</span>，同时预处理出它们的 <span class="math inline">\(T(F)\)</span> 值。首先，如果构成 <span class="math inline">\(F\)</span> 用了 <span class="math inline">\(k\)</span> 次操作4，每次使用前的 <span class="math inline">\(L\)</span> 值为 <span class="math inline">\(L_1\le L_2\le\cdots\le L_k\)</span>，那么 <span class="math inline">\(F=\prod_{i=1}^kL_i\)</span>，<span class="math inline">\(T(F)=L_k+k+1\)</span>。因此如果要判断 <span class="math inline">\(F\)</span> 能否得到或者求 <span class="math inline">\(T(F)\)</span> 的值，可以</p>
<ul>
<li>枚举最大的 <span class="math inline">\(L_k\)</span></li>
<li>然后找一条最短从大到小加入 <span class="math inline">\(L_i\)</span> 的途径，使得 <span class="math inline">\(F=\prod_{i=1}^kL_i\)</span></li>
</ul>
<p><strong>注意 <span class="math inline">\(F=1\)</span> 时不需要用操作4，所以要特判。</strong></p>
<p>定义结点 <span class="math inline">\((i,x)\)</span> 表示当前 <span class="math inline">\(F=x\)</span>，目前用于构成 <span class="math inline">\(x\)</span> 的最小 <span class="math inline">\(L\)</span> 值为 <span class="math inline">\(i\)</span>。之后</p>
<ul>
<li>初始化结点 <span class="math inline">\((i,i)\)</span>（<span class="math inline">\(i\le T\)</span>）的距离为 <span class="math inline">\(i+1\)</span>；</li>
<li>对每个结点 <span class="math inline">\((i,x)\)</span> 和正整数 <span class="math inline">\(j\le\min\{i,\frac{C_\max}{x}\}\)</span>，从 <span class="math inline">\((i,x)\)</span> 到 <span class="math inline">\((j,jx)\)</span> 连长度为 <span class="math inline">\(1\)</span> 的边。</li>
</ul>
<p>其中 <span class="math inline">\(C_\max=10^8\)</span>。初始化距离还可以做得更简单一些，只初始化 <span class="math inline">\((2,2)\)</span> 的距离为 <span class="math inline">\(3\)</span>，然后对每个结点 <span class="math inline">\((i,i)\)</span>（<span class="math inline">\(i &lt; T\)</span>），从 <span class="math inline">\((i,i)\)</span> 到 <span class="math inline">\((i+1,i+1)\)</span> 连长度为 <span class="math inline">\(1\)</span> 的边。</p>
<p>然后，以 <span class="math inline">\((2,2)\)</span> 为源点做一遍BFS，那么所有到达的点 <span class="math inline">\((1,x)\)</span> 对应的 <span class="math inline">\(x\)</span> 均可取作 <span class="math inline">\(F\)</span>，<span class="math inline">\((1,F)\)</span> 的距离就是 <span class="math inline">\(T(F)\)</span>。</p>
<p>实测表明BFS的总状态数不超过 <span class="math inline">\(8\times 10^6\)</span>，总转移数约为 <span class="math inline">\(3.5\times 10^7\)</span>，完全可以接受。然而BFS时如何记录这些状态哪些已被访问过？由于可到达的状态 <span class="math inline">\((i,x)\)</span> 都满足 <span class="math inline">\(i|x\)</span>，预处理 <span class="math inline">\(A_i=\sum_{j=1}^{i-1}\lfloor\frac{C_\max}{i}\rfloor\)</span>（其中 <span class="math inline">\(C_\max=10^8\)</span>），则状态 <span class="math inline">\((i,x)\)</span> 可以映射为正整数 <span class="math inline">\(A_i+\frac{x}{i}\)</span>，用这个整数作为状态的hash值是不会冲突的。并且这个数不超过 <span class="math inline">\(5.2\times 10^8\)</span>，用一个 <code>bitset</code> 就能存下了。（我手写了 <code>bitset</code>）</p>
<p>于是我们成功找出了所有合法的 <span class="math inline">\(F\)</span> 及其 <span class="math inline">\(T(F)\)</span> 值，将其按照 <span class="math inline">\(F\)</span> 从小到大排序。最后只差一步了——枚举 <span class="math inline">\(F_1,F_2\)</span> 并判断是否有</p>
<p><span class="math display">\[F_1+F_2\le C\]</span></p>
<p><span class="math display">\[C-F_1-F_2\le T-T(F_1)-T(F_2)\]</span></p>
<p>的复杂度是 <span class="math inline">\(O(c_F^2)\)</span> 的（<span class="math inline">\(c_F\)</span> 为满足要求的 <span class="math inline">\(F\)</span> 个数），需要优化。这两个约束可以改写成</p>
<p><span class="math display">\[F_2\le C-F_1\]</span></p>
<p><span class="math display">\[C-F_1+T(F_1)-T\le F_2-T(F_2)\]</span></p>
<p>所以只需预处理 <span class="math inline">\(F-T(F)\)</span> 的前缀最大值，即 <span class="math inline">\(M(F)=\max_{F&#39;\le F}\{F&#39;-T(F&#39;)\}\)</span>，就可以只枚举 <span class="math inline">\(F_1\)</span>，用Two-pointers方法找出最大的 <span class="math inline">\(F_2\)</span> 满足 <span class="math inline">\(F_2\le C-F_1\)</span>，然后 <span class="math inline">\(O(1)\)</span> 判断是否有 <span class="math inline">\(C-F_1+T(F_1)-T\le M(F_2)\)</span> 就做完了。</p>
<p>预处理复杂度难以估计（但对于极限数据的测试不到 <span class="math inline">\(1\texttt{s}\)</span>），查询总复杂度为 <span class="math inline">\(O(m\cdot c_F)\)</span>，其中 <span class="math inline">\(c_F &lt; 10^6\)</span>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,mc,a[<span class="number">110</span>],w[<span class="number">110</span>],C[<span class="number">1010</span>],maxc,f[<span class="number">110</span>][<span class="number">110</span>],add[<span class="number">110</span>],cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?a:b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cmax</span><span class="params">(<span class="keyword">int</span>&amp;a,<span class="keyword">int</span> b)</span></span>&#123;b&gt;a?a=b:<span class="number">1</span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">item</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> i,x,d;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> item&amp;it)<span class="keyword">const</span>&#123;<span class="keyword">return</span> x&lt;it.x;&#125;</span><br><span class="line">&#125;Q[<span class="number">7840010</span>],*H=Q,*T=Q,S[<span class="number">930000</span>];</span><br><span class="line">ull vis[<span class="number">8110000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ext</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c=add[i]+x;</span><br><span class="line">	<span class="keyword">if</span>(!(vis[c&gt;&gt;<span class="number">6</span>]&gt;&gt;(c&amp;<span class="number">63</span>)&amp;<span class="number">1</span>))vis[c&gt;&gt;<span class="number">6</span>]|=<span class="number">1u</span>ll&lt;&lt;(c&amp;<span class="number">63</span>),*(T++)=(item)&#123;i,i*x,d&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pmax[<span class="number">930000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> lim,<span class="keyword">int</span> tot)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;tot;i++)add[i+<span class="number">1</span>]=add[i]+lim/i;</span><br><span class="line">	ext(<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">for</span>(;H&lt;T;H++)&#123;</span><br><span class="line">		<span class="keyword">int</span> jmax=lim/H-&gt;x;</span><br><span class="line">		<span class="keyword">if</span>(jmax&gt;H-&gt;i)jmax=H-&gt;i;</span><br><span class="line">		<span class="keyword">if</span>(H-&gt;i&lt;tot&amp;&amp;H-&gt;i==H-&gt;x)ext(H-&gt;i+<span class="number">1</span>,<span class="number">1</span>,H-&gt;d+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(H-&gt;i&gt;<span class="number">1</span>)<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=jmax;j++)ext(j,H-&gt;x,H-&gt;d+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> S[cnt++]=*H;</span><br><span class="line">	&#125;</span><br><span class="line">	S[cnt++]=(item)&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="built_in">std</span>::sort(S,S+cnt);</span><br><span class="line">	*pmax=-inf;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)cmax(pmax[i+<span class="number">1</span>]=S[i].x-S[i].d,pmax[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(c&lt;=t)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=cnt,j=<span class="number">0</span>;i--;)<span class="keyword">if</span>(S[i].x&lt;=c)&#123;</span><br><span class="line">		<span class="keyword">while</span>(j&lt;cnt&amp;&amp;S[i].x+S[j].x&lt;=c)j++;</span><br><span class="line">		<span class="keyword">if</span>(c-S[i].x&lt;=t-S[i].d||c-S[i].x+S[i].d&lt;=t+pmax[j])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;mc);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,w+i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,C+i),cmax(maxc,C[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=mc;j++)f[i][j]=-inf;</span><br><span class="line">	<span class="keyword">int</span> t=f[<span class="number">0</span>][mc]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=mc;j++)<span class="keyword">if</span>(f[i][j]&gt;=<span class="number">0</span>&amp;&amp;j-a[i]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">		cmax(f[i+<span class="number">1</span>][j-a[i]],f[i][j]+<span class="number">1</span>);</span><br><span class="line">		cmax(f[i+<span class="number">1</span>][min(j-a[i]+w[i],mc)],f[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=mc;j++)cmax(t,f[i][j]);</span><br><span class="line">	init(maxc,t);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,check(t,C[i]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="d2t3抛硬币">D2T3：抛硬币</h3>
<p>这题也很妙，我搞了很久。</p>
<p>看完题发现题目要求的其实是这么一个东西：</p>
<p><span class="math display">\[\sum_{x=0}^a\sum_{y=0}^b[x&gt;y]{a\choose x}{b\choose y}\bmod 10^k\]</span></p>
<p>然后没想到怎么求。。。就把 <span class="math inline">\(f(a,b)=\sum_{x=0}^a\sum_{y=0}^b[x&gt;y]{a\choose x}{b\choose y}\)</span> 打了个表看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   0 </span><br><span class="line">   1      1 </span><br><span class="line">   3      4      5 </span><br><span class="line">   7     11     16     22 </span><br><span class="line">  15     26     42     64     93 </span><br><span class="line">  31     57     99    163    256    386 </span><br><span class="line">  63    120    219    382    638   1024   1586 </span><br><span class="line"> 127    247    466    848   1486   2510   4096   6476 </span><br><span class="line"> 255    502    968   1816   3302   5812   9908  16384  26333 </span><br><span class="line"> 511   1013   1981   3797   7099  12911  22819  39203  65536 106762 </span><br><span class="line">1023   2036   4017   7814  14913  27824  50643  89846 155382 262144 431910</span><br></pre></td></tr></table></figure>
<p>发现了很多性质，比如</p>
<ul>
<li><span class="math inline">\(f(b+1,b)=4^b\)</span></li>
<li><span class="math inline">\(f(a,0)=2^a-1\)</span></li>
<li><span class="math inline">\(f(a,b)=f(a-1,b)+f(a-1,b+1)\)</span></li>
<li>……</li>
</ul>
<p>然而倒数第二条对角线的规律这么明显，第一条对角线的规律我居然没看出来？这不科学！我想知道 <span class="math inline">\(f(a,a)\)</span> 是个啥玩意。</p>
<p><span class="math display">\[f(a,a)=\sum_{0\le y &lt; x\le a}{a\choose x}{a\choose y}=\sum_{0\le x &lt; y\le a}{a\choose x}{a\choose y}\]</span></p>
<p><span class="math display">\[2f(a,a)=\sum_{0\le x,y\le a,x\ne y}{a\choose x}{a\choose y}=\sum_{x=0}^a\sum_{y=0}^a{a\choose x}{a\choose y}-\sum_{x=0}^a{a\choose x}^2=\left(\sum_{x=0}^a{a\choose x}\right)^2-\sum_{x=0}^a{a\choose x}^2=4^a-\sum_{x=0}^a{a\choose x}^2\]</span></p>
<p>然后我发现我不会求 <span class="math inline">\(\sum_{x=0}^a{a\choose x}^2\)</span>，怎么办？继续打 <span class="math inline">\(g(a)=\sum_{x=0}^a{a\choose x}^2\)</span> 的表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 6 20 70 252 924 3432 12870 48620 184756</span><br></pre></td></tr></table></figure>
<p>组合数既视感……再把组合数表打出来看，看出来是对称轴上的数，也就是 <span class="math inline">\(g(a)={2a\choose a}\)</span>。为什么呢？</p>
<p>想了一下就想明白了：</p>
<p><span class="math display">\[g(a)=\sum_{x=0}^a{a\choose x}{a\choose x}=\sum_{x=0}^a{a\choose x}{a\choose a-x}\]</span></p>
<p>设两个集合 <span class="math inline">\(A,B\)</span>，满足 <span class="math inline">\(|A|=|B|=a\)</span>，<span class="math inline">\(A\cap B=\varnothing\)</span>，则</p>
<p><span class="math display">\[g(a)=\sum_{S\subseteq A}\sum_{T\subseteq B}[|T|=a-|S|]=\sum_{S\subseteq A}\sum_{T\subseteq B}[|S|+|T|=a]=\sum_{X\subseteq A\cup B}[|X|=a]={2a\choose a}\]</span></p>
<p>这样就可以做了？然而 <span class="math inline">\(a,b\)</span> 范围很大，并不知道如何优化。唯一有用的条件是 <span class="math inline">\(a-b\)</span> 很小，也就是说要求的值离对角线很近，能不能用对角线上的值暴力递推？</p>
<p>接着发现暴力递推的复杂度是 <span class="math inline">\(O((a-b)^2)\)</span>，多组数据下并不能过……</p>
<p>感觉有点掉坑？</p>
<p>准备重新想下整个题。再把式子列出来：</p>
<p><span class="math display">\[f(a,b)=\sum_{x=0}^a\sum_{y=0}^b[x&gt;y]{a\choose x}{b\choose y}\]</span></p>
<p>嗯，这似乎可以用之前化简 <span class="math inline">\(\sum_{x=0}^a{a\choose x}{a\choose x}\)</span> 的思路来做！</p>
<p><span class="math display">\[f(a,b)=\sum_{x=0}^a\sum_{y=0}^b[a-x&gt;y]{a\choose a-x}{b\choose y}=\sum_{x=0}^a\sum_{y=0}^b[x+y &lt; a]{a\choose a-x}{b\choose y}=\sum_{x=0}^{a-1}{a+b\choose x}\]</span></p>
<p>妙！这下就简单多了。</p>
<p>设 <span class="math inline">\(S=\sum_{x=0}^{\lfloor\frac{a+b}{2}\rfloor}{a+b\choose x}\)</span>，则</p>
<p><span class="math display">\[2S=\sum_{x=0}^{\lfloor\frac{a+b}{2}\rfloor}{a+b\choose x}+\sum_{x=a+b-\lfloor\frac{a+b}{2}\rfloor}^{a+b}{a+b\choose x}=\sum_{x=0}^{a+b}{a+b\choose x}+[2|a+b]{a+b\choose\frac{a+b}{2}}=2^{a+b}-[2|a+b]{a+b\choose\frac{a+b}{2}}\]</span></p>
<p><span class="math display">\[S=2^{a+b-1}+[2|a+b]\frac{1}{2}{a+b\choose\frac{a+b}{2}}=2^{a+b-1}+[2|a+b]{a+b-1\choose\frac{a+b}{2}-1}\]</span></p>
<p>因为 <span class="math inline">\(a,b\)</span> 相差不大，所以可以暴力枚举 <span class="math inline">\(x\)</span> 求和 <span class="math inline">\(\sum_{x=\lfloor\frac{a+b}{2}\rfloor+1}^{a-1}{a+b\choose x}\)</span>，加上 <span class="math inline">\(S\)</span> 就是答案。注意判 <span class="math inline">\(a=b\)</span> 的情况。现在问题转化为求大组合数，当然由于题目要求模 <span class="math inline">\(10^k\)</span>，我们也只要求大组合数模 <span class="math inline">\(10^k\)</span> 即可。</p>
<p>考虑求这个东西：</p>
<p><span class="math display">\[{a\choose b}\bmod 10^k\]</span></p>
<p>由于 <span class="math inline">\(10^k\)</span> 不是质数，甚至 <span class="math inline">\(10\)</span> 都不是质数，无法使用Lucas定理。因为 <span class="math inline">\(10^k=2^k\times 5^k\)</span>，且 <span class="math inline">\((2,5)=1\)</span>，可以算出 <span class="math inline">\({a\choose b}\bmod 2^k\)</span> 和 <span class="math inline">\({a\choose b}\bmod 5^k\)</span>，然后使用中国剩余定理合并。考虑如何计算 <span class="math inline">\({a\choose b}\bmod p^k\)</span>，其中 <span class="math inline">\(p\in\{2,5\}\)</span>，<span class="math inline">\(k\le 9\)</span>。</p>
<p>因为 <span class="math inline">\({a\choose b}=\frac{a!}{b!{a-b}!}\)</span>，阶乘中可能有多个质因子 <span class="math inline">\(p\)</span>，需要将其提取出来。记 <span class="math inline">\(a!=v_ap^{t_a}\)</span>，其中 <span class="math inline">\(p\not\lvert a&#39;\)</span>，因为</p>
<p><span class="math display">\[a!=\prod_{i=1}^ai!=\prod_{1\le i\le a,p\not\lvert i}i\cdot\prod_{1\le i\le a,p|i}i=\prod_{1\le i\le a,p\not\lvert i}i\cdot\prod_{i=1}^{\lfloor\frac{a}{p}\rfloor}pi=\lfloor\frac{a}{p}\rfloor!p^{\lfloor\frac{a}{p}\rfloor}\prod_{1\le i\le a,p\not\lvert i}i\]</span></p>
<p>这个过程可以递归下去，<span class="math inline">\(a\)</span> 会变成 <span class="math inline">\(\lfloor\frac{a}{p}\rfloor,\lfloor\frac{a}{p^2}\rfloor,\lfloor\frac{a}{p^3}\rfloor\cdots\)</span>，由此得到</p>
<p><span class="math display">\[a!=\prod_{t=0}^{\lfloor\log_pa\rfloor}\left(p^{\lfloor\frac{a}{p^{t+1}}\rfloor}\prod_{1\le i\le\lfloor\frac{a}{p^t}\rfloor,p\not\lvert i}i\right)\]</span></p>
<p>于是</p>
<p><span class="math display">\[v_a=\prod_{t=0}^{\lfloor\log_pa\rfloor}\prod_{1\le i\le\lfloor\frac{a}{p^t}\rfloor,p\not\lvert i}i\]</span></p>
<p><span class="math display">\[t_a=\sum_{t=0}^{\lfloor\log_pa\rfloor}\lfloor\frac{a}{p^{t+1}}\rfloor\]</span></p>
<p>类似地求出 <span class="math inline">\(v_b,t_b,v_{a-b},t_{a-b}\)</span>，可以得到 <span class="math inline">\({a\choose b}\bmod p^k=\frac{v_a}{v_bv_{a-b}}p^{t_a-t_b-t_{a-b}}\bmod p^k\)</span>。这里的 <span class="math inline">\(v_a\)</span> 和 <span class="math inline">\(t_a\)</span> 两部分的计算都是可以优化的：</p>
<p>1、<span class="math inline">\(v_a\)</span> 只需在模 <span class="math inline">\(p^k\)</span> 意义下计算，可以用模意义下的循环节优化：</p>
<p><span class="math display">\[v_a\bmod p=\prod_{t=0}^{\lfloor\log_pa\rfloor}\left(\prod_{q=1}^{\lfloor\frac{a}{p^{k+t}}\rfloor}\prod_{p^k(q-1)+1\le i &lt; p^kq,p\not\lvert i}i\cdot\prod_{\lfloor\frac{a}{p^{k+t}}\rfloor p^k+1\le i\le\lfloor\frac{a}{p^t}\rfloor,p\not\lvert i}i\right)\bmod p\]</span></p>
<p>对 <span class="math inline">\(i=0,1,\cdots,p^k-1\)</span> 预处理 <span class="math inline">\(P_i=\prod_{1\le j\le i,p\not\lvert j}j\)</span>，则</p>
<p><span class="math display">\[v_a\bmod p=\prod_{t=0}^{\lfloor\log_pa\rfloor}P_{p^k-1}^{\lfloor\frac{a}{p^{k+t}}\rfloor}P_{\lfloor\frac{a}{p^t}\rfloor\bmod p^k}\bmod p^k\]</span></p>
<p>这个预处理的复杂度是 <span class="math inline">\(O(p^k)\)</span>，由于 <span class="math inline">\(p^k\le 5^9\)</span>，预处理时间完全可以接受。<strong>另外，<span class="math inline">\(v_b,v_{a-b}\)</span> 需要计算的是模 <span class="math inline">\(p^k\)</span> 意义下的乘法逆元</strong>。</p>
<p>2、不用求出 <span class="math inline">\(t_a,t_b,t_{a-b}\)</span>，只需求 <span class="math inline">\(t_a-t_b-t_{a-b}\)</span>，即</p>
<p><span class="math display">\[t_a-t_b-t_{a-b}=\sum_{t=0}^{\lfloor\log_pa\rfloor}\left(\lfloor\frac{a}{p^{t+1}}\rfloor-\lfloor\frac{b}{p^{t+1}}\rfloor-\lfloor\frac{a-b}{p^{t+1}}\rfloor\right)\]</span></p>
<p>考虑进位，我们发现 <span class="math inline">\(\lfloor\frac{a}{p^{t+1}}\rfloor=\begin{cases}\lfloor\frac{b}{p^{t+1}}\rfloor+\lfloor\frac{a-b}{p^{t+1}}\rfloor,&amp;a\bmod p^{t+1}\ge b\bmod p^{t+1},\\ \lfloor\frac{b}{p^{t+1}}\rfloor+\lfloor\frac{a-b}{p^{t+1}}\rfloor+1,&amp;a\bmod p^{t+1}&lt; b\bmod p^{t+1}\end{cases}\)</span>，因此上式可化简为</p>
<p><span class="math display">\[t_a-t_b-t_{a-b}=\sum_{t=0}^{\lfloor\log_pa\rfloor}[a\bmod p^{t+1}&lt; b\bmod p^{t+1}]\]</span></p>
<p>分析到这里，我们可以用 <span class="math inline">\(O(\log a)\)</span> 的时间求 <span class="math inline">\({a\choose b}\bmod p^k\)</span> 了。直接套之前的公式就能以 <span class="math inline">\(O(5^k+(a-b)\log a)\)</span> 的复杂度解决本题了。</p>
<p>但是这样还是太慢，怎么办？我纠结了很长一段时间。。。最后去看了这题BZOJ上#1的whzzt写的题解。。。</p>
<p>原来。。。只要这么搞就行了</p>
<p><span class="math display">\[{a\choose b+1}={a\choose b}\frac{a-b}{b+1}\]</span></p>
<p>预处理逆元以及log以内的 <span class="math inline">\(p\)</span> 的幂，暴力分解+递推就可以优化掉复杂度里的log了。最后就是 <span class="math inline">\(O(5^k+T(a-b))\)</span>。<span class="math inline">\(T\)</span> 是数据组数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="function">ll <span class="title">pw</span><span class="params">(ll a,ll b,<span class="keyword">int</span> m)</span></span>&#123;ll c=<span class="number">1</span>;<span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)b%<span class="number">2</span>?c=c*a%m:<span class="number">1</span>,a=a*a%m;<span class="keyword">return</span> c;&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> m)</span></span>&#123;<span class="keyword">return</span> a==<span class="number">1</span>?<span class="number">1</span>:(<span class="number">1</span>+m*(a-inv(m%a,a)))/a%m;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod2=<span class="number">512</span>,mod5=<span class="number">1953125</span>,mod=mod2*mod5,maxt=<span class="number">60</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> m,ll*fac,ll*invs,ll*pws)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=*fac=<span class="number">1</span>;i&lt;m;i++)fac[i]=fac[i<span class="number">-1</span>]*(i%p?i:<span class="number">1</span>)%m;</span><br><span class="line">    invs[m<span class="number">-1</span>]=inv(fac[m<span class="number">-1</span>],m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m;--i;)invs[i<span class="number">-1</span>]=invs[i]*(i%p?i:<span class="number">1</span>)%m,(invs[i]*=fac[i<span class="number">-1</span>])%=m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=*pws=<span class="number">1</span>;i&lt;maxt;i++)pws[i]=pws[i<span class="number">-1</span>]*p%m;</span><br><span class="line">&#125;</span><br><span class="line">ll fac2[mod2],inv2[mod2],pw2[maxt],fac5[mod5],inv5[mod5],pw5[maxt],K2,K5;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">num</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,t,p,m;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>*=(ll x)&#123;<span class="keyword">while</span>(x&amp;&amp;x%p==<span class="number">0</span>)x/=p,t++;x%=m;a=a*x%m;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>/=(ll x)&#123;<span class="keyword">while</span>(x&amp;&amp;x%p==<span class="number">0</span>)x/=p,t--;x%=m;a=a*(p&lt;<span class="number">3</span>?inv2:inv5)[x]%m;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">val</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> a*(p&lt;<span class="number">3</span>?pw2:pw5)[t]%m;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">num <span class="title">C</span><span class="params">(ll a,ll b,<span class="keyword">int</span> p,<span class="keyword">int</span> m,ll*fac)</span></span>&#123;</span><br><span class="line">    ll P=<span class="number">1</span>;<span class="keyword">int</span> Q=<span class="number">0</span>,T=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll x=a,y=b,z=a-b,t=<span class="number">1</span>;x;x/=p,y/=p,z/=p,t*=p)&#123;</span><br><span class="line">        P=P*fac[x%m]%m*inv(fac[y%m]*fac[z%m]%m,m)%m;</span><br><span class="line">        Q+=a%(m*t)&lt;b%(m*t);T+=a%(p*t)&lt;b%(p*t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(num)&#123;P*pw(fac[m<span class="number">-1</span>],Q,m)%m,T,p,m&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(ll a,ll l,ll r)</span></span>&#123;</span><br><span class="line">    num c2=C(a,l,<span class="number">2</span>,mod2,fac2),c5=C(a,l,<span class="number">5</span>,mod5,fac5);</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll b=l;b&lt;=r;b++)&#123;</span><br><span class="line">        s=(s+c2.val()*K2+c5.val()*K5)%mod;</span><br><span class="line">        c2*=a-b;c2/=b+<span class="number">1</span>;c5*=a-b;c5/=b+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(ll a,ll b,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">1</span>;<span class="keyword">while</span>(k--)m*=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span>(pw(<span class="number">2</span>,a+b<span class="number">-1</span>,m)+(a+b&amp;<span class="number">1</span>?<span class="number">0</span>:calc(a+b<span class="number">-1</span>,a+b<span class="number">-1</span>&gt;&gt;<span class="number">1</span>,a+b<span class="number">-1</span>&gt;&gt;<span class="number">1</span>))+calc(a+b,(a+b)/<span class="number">2</span>+<span class="number">1</span>,a<span class="number">-1</span>)+mod-calc(a+b,a,a+b&gt;&gt;<span class="number">1</span>))%m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init(<span class="number">2</span>,mod2,fac2,inv2,pw2);</span><br><span class="line">    init(<span class="number">5</span>,mod5,fac5,inv5,pw5);</span><br><span class="line">    K2=mod5*inv(mod5%mod2,mod2);</span><br><span class="line">    K5=mod2*inv(mod2,mod5);</span><br><span class="line">    ll a,b;<span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld%lld%d"</span>,&amp;a,&amp;b,&amp;k)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">char</span> fm[<span class="number">6</span>]=&#123;<span class="string">'%'</span>,<span class="string">'0'</span>,k+<span class="number">48</span>,<span class="string">'d'</span>,<span class="string">'\n'</span>&#125;;</span><br><span class="line">        <span class="built_in">printf</span>(fm,solve(a,b,k));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/26/hnoi2017-record/" data-id="cjeh761b5001igy1lbazh06wg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HNOI/">HNOI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/题解/">题解</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/04/26/zjoi2017-record/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          ZJOI2017做题纪录
        
      </div>
    </a>
  
  
    <a href="/2017/04/23/fjoi2017-r2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">FJOI2017滚粗记</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/51nod/">51nod</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/APIO/">APIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AtCoder/">AtCoder</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTSC/">CTSC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Codechef/">Codechef</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Codeforces/">Codeforces</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FJOI/">FJOI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FJWC/">FJWC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HNOI/">HNOI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IOI/">IOI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LYDSY/">LYDSY</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NOI/">NOI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SDOI/">SDOI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SHOI/">SHOI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TopCoder/">TopCoder</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UOJ/">UOJ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WC/">WC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ZJOI/">ZJOI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/总结/">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板/">模板</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/清华集训/">清华集训</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/百度之星/">百度之星</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/省队集训/">省队集训</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/记录/">记录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/酱油记/">酱油记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/集训队互测/">集训队互测</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/题解/">题解</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/51nod/" style="font-size: 16.25px;">51nod</a> <a href="/tags/APIO/" style="font-size: 12.5px;">APIO</a> <a href="/tags/AtCoder/" style="font-size: 10px;">AtCoder</a> <a href="/tags/CTSC/" style="font-size: 11.25px;">CTSC</a> <a href="/tags/Codechef/" style="font-size: 10px;">Codechef</a> <a href="/tags/Codeforces/" style="font-size: 15px;">Codeforces</a> <a href="/tags/FJOI/" style="font-size: 12.5px;">FJOI</a> <a href="/tags/FJWC/" style="font-size: 10px;">FJWC</a> <a href="/tags/HNOI/" style="font-size: 10px;">HNOI</a> <a href="/tags/IOI/" style="font-size: 10px;">IOI</a> <a href="/tags/LYDSY/" style="font-size: 11.25px;">LYDSY</a> <a href="/tags/NOI/" style="font-size: 12.5px;">NOI</a> <a href="/tags/SDOI/" style="font-size: 10px;">SDOI</a> <a href="/tags/SHOI/" style="font-size: 10px;">SHOI</a> <a href="/tags/TopCoder/" style="font-size: 10px;">TopCoder</a> <a href="/tags/UOJ/" style="font-size: 13.75px;">UOJ</a> <a href="/tags/WC/" style="font-size: 10px;">WC</a> <a href="/tags/ZJOI/" style="font-size: 10px;">ZJOI</a> <a href="/tags/总结/" style="font-size: 17.5px;">总结</a> <a href="/tags/模板/" style="font-size: 10px;">模板</a> <a href="/tags/清华集训/" style="font-size: 11.25px;">清华集训</a> <a href="/tags/百度之星/" style="font-size: 10px;">百度之星</a> <a href="/tags/省队集训/" style="font-size: 11.25px;">省队集训</a> <a href="/tags/记录/" style="font-size: 11.25px;">记录</a> <a href="/tags/酱油记/" style="font-size: 20px;">酱油记</a> <a href="/tags/集训队互测/" style="font-size: 10px;">集训队互测</a> <a href="/tags/题解/" style="font-size: 18.75px;">题解</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/12/04/lydsy-3489/">LYDSY P3489 题解</a>
          </li>
        
          <li>
            <a href="/2017/10/29/codeforces-443/">Codeforces Round 443 总结</a>
          </li>
        
          <li>
            <a href="/2017/10/22/astar2017/">百度之星Astar决赛被虐记</a>
          </li>
        
          <li>
            <a href="/2017/10/15/codeforces-440/">Codeforces Round 440 总结</a>
          </li>
        
          <li>
            <a href="/2017/10/09/atcoder-codefestival2017-qualb/">AtCoder CODE FESTIVAL 2017 qual B 总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 j324h9<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="//cdn.bootcss.com/mathjax/2.6.0/MathJax.js?config=TeX-AMS_HTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>